/* automatically generated by rust-bindgen 0.72.0 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    fn extract_bit(byte: u8, index: usize) -> bool {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        Self::extract_bit(byte, index)
    }
    #[inline]
    pub unsafe fn raw_get_bit(this: *const Self, index: usize) -> bool {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = unsafe {
            *(core::ptr::addr_of!((*this).storage) as *const u8).offset(byte_index as isize)
        };
        Self::extract_bit(byte, index)
    }
    #[inline]
    fn change_bit(byte: u8, index: usize, val: bool) -> u8 {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val { byte | mask } else { byte & !mask }
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub unsafe fn raw_set_bit(this: *mut Self, index: usize, val: bool) {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = unsafe {
            (core::ptr::addr_of_mut!((*this).storage) as *mut u8).offset(byte_index as isize)
        };
        unsafe { *byte = Self::change_bit(*byte, index, val) };
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub unsafe fn raw_get(this: *const Self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if unsafe { Self::raw_get_bit(this, i + bit_offset) } {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
    #[inline]
    pub unsafe fn raw_set(this: *mut Self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            unsafe { Self::raw_set_bit(this, index + bit_offset, val_bit_is_set) };
        }
    }
}
pub const FT_OPEN_BY_SERIAL_NUMBER: u32 = 1;
pub const FT_OPEN_BY_DESCRIPTION: u32 = 2;
pub const FT_OPEN_BY_LOCATION: u32 = 4;
pub const FT_OPEN_MASK: u32 = 7;
pub const FT_LIST_NUMBER_ONLY: u32 = 2147483648;
pub const FT_LIST_BY_INDEX: u32 = 1073741824;
pub const FT_LIST_ALL: u32 = 536870912;
pub const FT_LIST_MASK: u32 = 3758096384;
pub const FT_BAUD_300: u32 = 300;
pub const FT_BAUD_600: u32 = 600;
pub const FT_BAUD_1200: u32 = 1200;
pub const FT_BAUD_2400: u32 = 2400;
pub const FT_BAUD_4800: u32 = 4800;
pub const FT_BAUD_9600: u32 = 9600;
pub const FT_BAUD_14400: u32 = 14400;
pub const FT_BAUD_19200: u32 = 19200;
pub const FT_BAUD_38400: u32 = 38400;
pub const FT_BAUD_57600: u32 = 57600;
pub const FT_BAUD_115200: u32 = 115200;
pub const FT_BAUD_230400: u32 = 230400;
pub const FT_BAUD_460800: u32 = 460800;
pub const FT_BAUD_921600: u32 = 921600;
pub const FT_FLOW_NONE: u32 = 0;
pub const FT_FLOW_RTS_CTS: u32 = 256;
pub const FT_FLOW_DTR_DSR: u32 = 512;
pub const FT_FLOW_XON_XOFF: u32 = 1024;
pub const FT_PURGE_RX: u32 = 1;
pub const FT_PURGE_TX: u32 = 2;
pub const FT_EVENT_RXCHAR: u32 = 1;
pub const FT_EVENT_MODEM_STATUS: u32 = 2;
pub const FT_EVENT_LINE_STATUS: u32 = 4;
pub const FT_DEFAULT_RX_TIMEOUT: u32 = 300;
pub const FT_DEFAULT_TX_TIMEOUT: u32 = 300;
pub const FT_BITMODE_RESET: u32 = 0;
pub const FT_BITMODE_ASYNC_BITBANG: u32 = 1;
pub const FT_BITMODE_MPSSE: u32 = 2;
pub const FT_BITMODE_SYNC_BITBANG: u32 = 4;
pub const FT_BITMODE_MCU_HOST: u32 = 8;
pub const FT_BITMODE_FAST_SERIAL: u32 = 16;
pub const FT_BITMODE_CBUS_BITBANG: u32 = 32;
pub const FT_BITMODE_SYNC_FIFO: u32 = 64;
pub const FT_232R_CBUS_TXDEN: u32 = 0;
pub const FT_232R_CBUS_PWRON: u32 = 1;
pub const FT_232R_CBUS_RXLED: u32 = 2;
pub const FT_232R_CBUS_TXLED: u32 = 3;
pub const FT_232R_CBUS_TXRXLED: u32 = 4;
pub const FT_232R_CBUS_SLEEP: u32 = 5;
pub const FT_232R_CBUS_CLK48: u32 = 6;
pub const FT_232R_CBUS_CLK24: u32 = 7;
pub const FT_232R_CBUS_CLK12: u32 = 8;
pub const FT_232R_CBUS_CLK6: u32 = 9;
pub const FT_232R_CBUS_IOMODE: u32 = 10;
pub const FT_232R_CBUS_BITBANG_WR: u32 = 11;
pub const FT_232R_CBUS_BITBANG_RD: u32 = 12;
pub const FT_232H_CBUS_TRISTATE: u32 = 0;
pub const FT_232H_CBUS_TXLED: u32 = 1;
pub const FT_232H_CBUS_RXLED: u32 = 2;
pub const FT_232H_CBUS_TXRXLED: u32 = 3;
pub const FT_232H_CBUS_PWREN: u32 = 4;
pub const FT_232H_CBUS_SLEEP: u32 = 5;
pub const FT_232H_CBUS_DRIVE_0: u32 = 6;
pub const FT_232H_CBUS_DRIVE_1: u32 = 7;
pub const FT_232H_CBUS_IOMODE: u32 = 8;
pub const FT_232H_CBUS_TXDEN: u32 = 9;
pub const FT_232H_CBUS_CLK30: u32 = 10;
pub const FT_232H_CBUS_CLK15: u32 = 11;
pub const FT_232H_CBUS_CLK7_5: u32 = 12;
pub const FT_X_SERIES_CBUS_TRISTATE: u32 = 0;
pub const FT_X_SERIES_CBUS_TXLED: u32 = 1;
pub const FT_X_SERIES_CBUS_RXLED: u32 = 2;
pub const FT_X_SERIES_CBUS_TXRXLED: u32 = 3;
pub const FT_X_SERIES_CBUS_PWREN: u32 = 4;
pub const FT_X_SERIES_CBUS_SLEEP: u32 = 5;
pub const FT_X_SERIES_CBUS_DRIVE_0: u32 = 6;
pub const FT_X_SERIES_CBUS_DRIVE_1: u32 = 7;
pub const FT_X_SERIES_CBUS_IOMODE: u32 = 8;
pub const FT_X_SERIES_CBUS_TXDEN: u32 = 9;
pub const FT_X_SERIES_CBUS_CLK24: u32 = 10;
pub const FT_X_SERIES_CBUS_CLK12: u32 = 11;
pub const FT_X_SERIES_CBUS_CLK6: u32 = 12;
pub const FT_X_SERIES_CBUS_BCD_CHARGER: u32 = 13;
pub const FT_X_SERIES_CBUS_BCD_CHARGER_N: u32 = 14;
pub const FT_X_SERIES_CBUS_I2C_TXE: u32 = 15;
pub const FT_X_SERIES_CBUS_I2C_RXF: u32 = 16;
pub const FT_X_SERIES_CBUS_VBUS_SENSE: u32 = 17;
pub const FT_X_SERIES_CBUS_BITBANG_WR: u32 = 18;
pub const FT_X_SERIES_CBUS_BITBANG_RD: u32 = 19;
pub const FT_X_SERIES_CBUS_TIMESTAMP: u32 = 20;
pub const FT_X_SERIES_CBUS_KEEP_AWAKE: u32 = 21;
pub const FT_DRIVER_TYPE_D2XX: u32 = 0;
pub const FT_DRIVER_TYPE_VCP: u32 = 1;
pub type DWORD = ::std::os::raw::c_uint;
pub type ULONG = ::std::os::raw::c_uint;
pub type USHORT = ::std::os::raw::c_ushort;
pub type UCHAR = ::std::os::raw::c_uchar;
pub type WORD = ::std::os::raw::c_ushort;
pub type BYTE = ::std::os::raw::c_uchar;
pub type BOOL = ::std::os::raw::c_uint;
pub type CHAR = ::std::os::raw::c_uchar;
pub type PUCHAR = *mut UCHAR;
pub type PCHAR = *mut ::std::os::raw::c_char;
pub type PVOID = *mut ::std::os::raw::c_void;
pub type HANDLE = *mut ::std::os::raw::c_void;
pub type LONG = ::std::os::raw::c_uint;
pub type UINT = ::std::os::raw::c_uint;
pub type LPCTSTR = *const ::std::os::raw::c_char;
pub type LPDWORD = *mut DWORD;
pub type LPWORD = *mut WORD;
pub type PULONG = *mut ULONG;
pub type LPLONG = *mut LONG;
pub type LPVOID = PVOID;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _OVERLAPPED {
    pub Internal: DWORD,
    pub InternalHigh: DWORD,
    pub __bindgen_anon_1: _OVERLAPPED__bindgen_ty_1,
    pub hEvent: HANDLE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _OVERLAPPED__bindgen_ty_1 {
    pub __bindgen_anon_1: _OVERLAPPED__bindgen_ty_1__bindgen_ty_1,
    pub Pointer: PVOID,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _OVERLAPPED__bindgen_ty_1__bindgen_ty_1 {
    pub Offset: DWORD,
    pub OffsetHigh: DWORD,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _OVERLAPPED__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::size_of::<_OVERLAPPED__bindgen_ty_1__bindgen_ty_1>() - 8usize];
    ["Alignment of _OVERLAPPED__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::align_of::<_OVERLAPPED__bindgen_ty_1__bindgen_ty_1>() - 4usize];
    ["Offset of field: _OVERLAPPED__bindgen_ty_1__bindgen_ty_1::Offset"]
        [::std::mem::offset_of!(_OVERLAPPED__bindgen_ty_1__bindgen_ty_1, Offset) - 0usize];
    ["Offset of field: _OVERLAPPED__bindgen_ty_1__bindgen_ty_1::OffsetHigh"]
        [::std::mem::offset_of!(_OVERLAPPED__bindgen_ty_1__bindgen_ty_1, OffsetHigh) - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _OVERLAPPED__bindgen_ty_1"]
        [::std::mem::size_of::<_OVERLAPPED__bindgen_ty_1>() - 8usize];
    ["Alignment of _OVERLAPPED__bindgen_ty_1"]
        [::std::mem::align_of::<_OVERLAPPED__bindgen_ty_1>() - 8usize];
    ["Offset of field: _OVERLAPPED__bindgen_ty_1::Pointer"]
        [::std::mem::offset_of!(_OVERLAPPED__bindgen_ty_1, Pointer) - 0usize];
};
impl Default for _OVERLAPPED__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _OVERLAPPED"][::std::mem::size_of::<_OVERLAPPED>() - 24usize];
    ["Alignment of _OVERLAPPED"][::std::mem::align_of::<_OVERLAPPED>() - 8usize];
    ["Offset of field: _OVERLAPPED::Internal"]
        [::std::mem::offset_of!(_OVERLAPPED, Internal) - 0usize];
    ["Offset of field: _OVERLAPPED::InternalHigh"]
        [::std::mem::offset_of!(_OVERLAPPED, InternalHigh) - 4usize];
    ["Offset of field: _OVERLAPPED::hEvent"][::std::mem::offset_of!(_OVERLAPPED, hEvent) - 16usize];
};
impl Default for _OVERLAPPED {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type LPOVERLAPPED = *mut _OVERLAPPED;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SECURITY_ATTRIBUTES {
    pub nLength: DWORD,
    pub lpSecurityDescriptor: LPVOID,
    pub bInheritHandle: BOOL,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _SECURITY_ATTRIBUTES"][::std::mem::size_of::<_SECURITY_ATTRIBUTES>() - 24usize];
    ["Alignment of _SECURITY_ATTRIBUTES"][::std::mem::align_of::<_SECURITY_ATTRIBUTES>() - 8usize];
    ["Offset of field: _SECURITY_ATTRIBUTES::nLength"]
        [::std::mem::offset_of!(_SECURITY_ATTRIBUTES, nLength) - 0usize];
    ["Offset of field: _SECURITY_ATTRIBUTES::lpSecurityDescriptor"]
        [::std::mem::offset_of!(_SECURITY_ATTRIBUTES, lpSecurityDescriptor) - 8usize];
    ["Offset of field: _SECURITY_ATTRIBUTES::bInheritHandle"]
        [::std::mem::offset_of!(_SECURITY_ATTRIBUTES, bInheritHandle) - 16usize];
};
impl Default for _SECURITY_ATTRIBUTES {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type LPSECURITY_ATTRIBUTES = *mut _SECURITY_ATTRIBUTES;
#[doc = " @name FT_HANDLE\n An opaque value used as a handle to an opened FT device."]
pub type FT_HANDLE = PVOID;
#[doc = " @{\n @name FT_STATUS\n @details Return status values for API calls."]
pub type FT_STATUS = ULONG;
pub const FT_OK: _bindgen_ty_11 = 0;
pub const FT_INVALID_HANDLE: _bindgen_ty_11 = 1;
pub const FT_DEVICE_NOT_FOUND: _bindgen_ty_11 = 2;
pub const FT_DEVICE_NOT_OPENED: _bindgen_ty_11 = 3;
pub const FT_IO_ERROR: _bindgen_ty_11 = 4;
pub const FT_INSUFFICIENT_RESOURCES: _bindgen_ty_11 = 5;
pub const FT_INVALID_PARAMETER: _bindgen_ty_11 = 6;
pub const FT_INVALID_BAUD_RATE: _bindgen_ty_11 = 7;
pub const FT_DEVICE_NOT_OPENED_FOR_ERASE: _bindgen_ty_11 = 8;
pub const FT_DEVICE_NOT_OPENED_FOR_WRITE: _bindgen_ty_11 = 9;
pub const FT_FAILED_TO_WRITE_DEVICE: _bindgen_ty_11 = 10;
pub const FT_EEPROM_READ_FAILED: _bindgen_ty_11 = 11;
pub const FT_EEPROM_WRITE_FAILED: _bindgen_ty_11 = 12;
pub const FT_EEPROM_ERASE_FAILED: _bindgen_ty_11 = 13;
pub const FT_EEPROM_NOT_PRESENT: _bindgen_ty_11 = 14;
pub const FT_EEPROM_NOT_PROGRAMMED: _bindgen_ty_11 = 15;
pub const FT_INVALID_ARGS: _bindgen_ty_11 = 16;
pub const FT_NOT_SUPPORTED: _bindgen_ty_11 = 17;
pub const FT_OTHER_ERROR: _bindgen_ty_11 = 18;
pub const FT_DEVICE_LIST_NOT_READY: _bindgen_ty_11 = 19;
pub type _bindgen_ty_11 = ::std::os::raw::c_uint;
#[doc = " @{\n @name Device Types\n @details Known supported FTDI device types supported by this library."]
pub type FT_DEVICE = ULONG;
pub const FT_DEVICE_BM: _bindgen_ty_12 = 0;
pub const FT_DEVICE_AM: _bindgen_ty_12 = 1;
pub const FT_DEVICE_100AX: _bindgen_ty_12 = 2;
pub const FT_DEVICE_UNKNOWN: _bindgen_ty_12 = 3;
pub const FT_DEVICE_2232C: _bindgen_ty_12 = 4;
pub const FT_DEVICE_232R: _bindgen_ty_12 = 5;
pub const FT_DEVICE_2232H: _bindgen_ty_12 = 6;
pub const FT_DEVICE_4232H: _bindgen_ty_12 = 7;
pub const FT_DEVICE_232H: _bindgen_ty_12 = 8;
pub const FT_DEVICE_X_SERIES: _bindgen_ty_12 = 9;
pub const FT_DEVICE_4222H_0: _bindgen_ty_12 = 10;
pub const FT_DEVICE_4222H_1_2: _bindgen_ty_12 = 11;
pub const FT_DEVICE_4222H_3: _bindgen_ty_12 = 12;
pub const FT_DEVICE_4222_PROG: _bindgen_ty_12 = 13;
pub const FT_DEVICE_900: _bindgen_ty_12 = 14;
pub const FT_DEVICE_930: _bindgen_ty_12 = 15;
pub const FT_DEVICE_UMFTPD3A: _bindgen_ty_12 = 16;
pub const FT_DEVICE_2233HP: _bindgen_ty_12 = 17;
pub const FT_DEVICE_4233HP: _bindgen_ty_12 = 18;
pub const FT_DEVICE_2232HP: _bindgen_ty_12 = 19;
pub const FT_DEVICE_4232HP: _bindgen_ty_12 = 20;
pub const FT_DEVICE_233HP: _bindgen_ty_12 = 21;
pub const FT_DEVICE_232HP: _bindgen_ty_12 = 22;
pub const FT_DEVICE_2232HA: _bindgen_ty_12 = 23;
pub const FT_DEVICE_4232HA: _bindgen_ty_12 = 24;
pub type _bindgen_ty_12 = ::std::os::raw::c_uint;
pub const FT_FLAGS_OPENED: _bindgen_ty_13 = 1;
pub const FT_FLAGS_HISPEED: _bindgen_ty_13 = 2;
#[doc = " @{\n @name FT_DEVICE_LIST_INFO_NODE Device Information Flags\n @par Summary\n These flags are used in the Flags member of FT_DEVICE_LIST_INFO_NODE to indicated the state of\n the device and speed of the device."]
pub type _bindgen_ty_13 = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " @noop FT_SetVIDPID\n @par Supported Operating Systems\n Linux\n Mac OS X (10.4 and later)\n @par Summary\n A command to include a custom VID and PID combination within the internal device list table.\n This will allow the driver to load for the specified VID and PID combination.\n @param dwVID Device Vendor ID (VID)\n @param dwPID Device Product ID (PID)\n @returns\n FT_OK if successful, otherwise the return value is an FT error code.\n @remarks\n By default, the driver will support a limited set of VID and PID matched devices (VID 0x0403\n with PIDs for standard FTDI devices only).\n @n In order to use the driver with other VID and PID combinations the FT_SetVIDPID function\n must be used prior to calling FT_ListDevices, FT_Open, FT_OpenEx or FT_CreateDeviceInfoList.\n @note Extra function for non-Windows platforms to compensate for lack of .INF file to specify\n Vendor and Product IDs."]
    pub fn FT_SetVIDPID(dwVID: DWORD, dwPID: DWORD) -> FT_STATUS;
}
unsafe extern "C" {
    #[doc = " @noop FT_GetVIDPID\n @par Supported Operating Systems\n Linux\n Mac OS X (10.4 and later)\n @par Summary\n A command to retrieve the current VID and PID combination from within the internal device list table.\n @param pdwVID Pointer to DWORD that will contain the internal VID\n @param pdwPID Pointer to DWORD that will contain the internal PID\n @returns\n FT_OK if successful, otherwise the return value is an FT error code.\n @remarks\n @note Extra function for non-Windows platforms to compensate for lack of .INF file to specify Vendor and Product IDs.\n @see FT_SetVIDPID."]
    pub fn FT_GetVIDPID(pdwVID: *mut DWORD, pdwPID: *mut DWORD) -> FT_STATUS;
}
unsafe extern "C" {
    #[doc = " @noop FT_CreateDeviceInfoList\n @par Supported Operating Systems\n Linux\n Mac OS X (10.4 and later)\n Windows (2000 and later)\n Windows CE (4.2 and later)\n @par Summary\n This function builds a device information list and returns the number of D2XX devices connected to the\n system. The list contains information about both unopen and open devices.\n @param lpdwNumDevs Pointer to unsigned long to store the number of devices connected.\n @returns\n FT_OK if successful, otherwise the return value is an FT error code.\n @remarks\n An application can use this function to get the number of devices attached to the system. It can then\n allocate space for the device information list and retrieve the list using FT_GetDeviceInfoList or\n FT_GetDeviceInfoDetail.\n @n If the devices connected to the system change, the device info list will not be updated until\n FT_CreateDeviceInfoList is called again.\n @see FT_GetDeviceInfoList\n @see FT_GetDeviceInfoDetail"]
    pub fn FT_CreateDeviceInfoList(lpdwNumDevs: LPDWORD) -> FT_STATUS;
}
#[doc = "  @noop FT_DEVICE_LIST_INFO_NODE\n @par Summary\n This structure is used for passing information about a device back from the FT_GetDeviceInfoList function.\n @see FT_GetDeviceInfoList"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ft_device_list_info_node {
    pub Flags: ULONG,
    pub Type: ULONG,
    pub ID: ULONG,
    pub LocId: DWORD,
    pub SerialNumber: [::std::os::raw::c_char; 16usize],
    pub Description: [::std::os::raw::c_char; 64usize],
    pub ftHandle: FT_HANDLE,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ft_device_list_info_node"]
        [::std::mem::size_of::<_ft_device_list_info_node>() - 104usize];
    ["Alignment of _ft_device_list_info_node"]
        [::std::mem::align_of::<_ft_device_list_info_node>() - 8usize];
    ["Offset of field: _ft_device_list_info_node::Flags"]
        [::std::mem::offset_of!(_ft_device_list_info_node, Flags) - 0usize];
    ["Offset of field: _ft_device_list_info_node::Type"]
        [::std::mem::offset_of!(_ft_device_list_info_node, Type) - 4usize];
    ["Offset of field: _ft_device_list_info_node::ID"]
        [::std::mem::offset_of!(_ft_device_list_info_node, ID) - 8usize];
    ["Offset of field: _ft_device_list_info_node::LocId"]
        [::std::mem::offset_of!(_ft_device_list_info_node, LocId) - 12usize];
    ["Offset of field: _ft_device_list_info_node::SerialNumber"]
        [::std::mem::offset_of!(_ft_device_list_info_node, SerialNumber) - 16usize];
    ["Offset of field: _ft_device_list_info_node::Description"]
        [::std::mem::offset_of!(_ft_device_list_info_node, Description) - 32usize];
    ["Offset of field: _ft_device_list_info_node::ftHandle"]
        [::std::mem::offset_of!(_ft_device_list_info_node, ftHandle) - 96usize];
};
impl Default for _ft_device_list_info_node {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "  @noop FT_DEVICE_LIST_INFO_NODE\n @par Summary\n This structure is used for passing information about a device back from the FT_GetDeviceInfoList function.\n @see FT_GetDeviceInfoList"]
pub type FT_DEVICE_LIST_INFO_NODE = _ft_device_list_info_node;
unsafe extern "C" {
    #[doc = " @noop FT_GetDeviceInfoList\n @par Supported Operating Systems\n Linux\n Mac OS X (10.4 and later)\n Windows (2000 and later)\n Windows CE (4.2 and later)\n @par Summary\n This function returns a device information list and the number of D2XX devices in the list.\n @param *pDest Pointer to an array of FT_DEVICE_LIST_INFO_NODE structures.\n @param lpdwNumDevs Pointer to the number of elements in the array.\n @returns\n FT_OK if successful, otherwise the return value is an FT error code.\n @remarks\n This function should only be called after calling FT_CreateDeviceInfoList. If the devices connected to the\n system change, the device info list will not be updated until FT_CreateDeviceInfoList is called again.\n Location ID information is not returned for devices that are open when FT_CreateDeviceInfoList is called.\n Information is not available for devices which are open in other processes. In this case, the Flags\n parameter of the FT_DEVICE_LIST_INFO_NODE will indicate that the device is open, but other fields will\n be unpopulated.\n @n The flag value is a 4-byte bit map containing miscellaneous data as defined Appendix A - Type\n Definitions. Bit 0 (least significant bit) of this number indicates if the port is open (1) or closed (0). Bit 1\n indicates if the device is enumerated as a high-speed USB device (2) or a full-speed USB device (0). The\n remaining bits (2 - 31) are reserved.\n @n The array of FT_DEVICE_LIST_INFO_NODES contains all available data on each device. The structure of\n FT_DEVICE_LIST_INFO_NODES is given in the Appendix. The storage for the list must be allocated by\n the application. The number of devices returned by FT_CreateDeviceInfoList can be used to do this.\n When programming in Visual Basic, LabVIEW or similar languages, FT_GetDeviceInfoDetail may be\n required instead of this function.\n @note Please note that Windows CE does not support location IDs. As such, the Location ID parameter in the\n structure will be empty.\n @see FT_CreateDeviceInfoList"]
    pub fn FT_GetDeviceInfoList(
        pDest: *mut FT_DEVICE_LIST_INFO_NODE,
        lpdwNumDevs: LPDWORD,
    ) -> FT_STATUS;
}
unsafe extern "C" {
    #[doc = " @noop FT_GetDeviceInfoDetail\n @par Supported Operating Systems\n Linux\n Mac OS X (10.4 and later)\n Windows (2000 and later)\n Windows CE (4.2 and later)\n @par Summary\n This function returns an entry from the device information list.\n @param dwIndex Index of the entry in the device info list.\n @param lpdwFlags Pointer to unsigned long to store the flag value.\n @param lpdwType Pointer to unsigned long to store device type.\n @param lpdwID Pointer to unsigned long to store device ID.\n @param lpdwLocId Pointer to unsigned long to store the device location ID.\n @param lpSerialNumber Pointer to buffer to store device serial number as a nullterminated string.\n @param lpDescription Pointer to buffer to store device description as a null-terminated string.\n @param *pftHandle Pointer to a variable of type FT_HANDLE where the handle will be stored.\n @returns\n FT_OK if successful, otherwise the return value is an FT error code.\n @remarks\n This function should only be called after calling FT_CreateDeviceInfoList. If the devices connected to the\n system change, the device info list will not be updated until FT_CreateDeviceInfoList is called again.\n @n The index value is zero-based.\n @n The flag value is a 4-byte bit map containing miscellaneous data as defined Appendix A - Type\n Definitions. Bit 0 (least significant bit) of this number indicates if the port is open (1) or closed (0). Bit 1\n indicates if the device is enumerated as a high-speed USB device (2) or a full-speed USB device (0). The\n remaining bits (2 - 31) are reserved.\n @n Location ID information is not returned for devices that are open when FT_CreateDeviceInfoList is called.\n Information is not available for devices which are open in other processes. In this case, the lpdwFlags\n parameter will indicate that the device is open, but other fields will be unpopulated.\n To return the whole device info list as an array of FT_DEVICE_LIST_INFO_NODE structures, use\n FT_CreateDeviceInfoList.\n @note Please note that Windows CE does not support location IDs. As such, the Location ID parameter in the\n structure will be empty.\n @see FT_CreateDeviceInfoList"]
    pub fn FT_GetDeviceInfoDetail(
        dwIndex: DWORD,
        lpdwFlags: LPDWORD,
        lpdwType: LPDWORD,
        lpdwID: LPDWORD,
        lpdwLocId: LPDWORD,
        lpSerialNumber: LPVOID,
        lpDescription: LPVOID,
        pftHandle: *mut FT_HANDLE,
    ) -> FT_STATUS;
}
unsafe extern "C" {
    #[doc = " @noop FT_ListDevices\n @par Summary\n Gets information concerning the devices currently connected. This function can return information such\n as the number of devices connected, the device serial number and device description strings, and the\n location IDs of connected devices.\n @param pvArg1 Meaning depends on dwFlags.\n @param pvArg2 Meaning depends on dwFlags.\n @param dwFlags Determines format of returned information.\n @returns\n FT_OK if successful, otherwise the return value is an FT error code.\n @remarks\n This function can be used in a number of ways to return different types of information. A more powerful\n way to get device information is to use the FT_CreateDeviceInfoList, FT_GetDeviceInfoList and\n FT_GetDeviceInfoDetail functions as they return all the available information on devices.\n In its simplest form, it can be used to return the number of devices currently connected. If\n FT_LIST_NUMBER_ONLY bit is set in dwFlags, the parameter pvArg1 is interpreted as a pointer to a\n DWORD location to store the number of devices currently connected.\n @n It can be used to return device information: if FT_OPEN_BY_SERIAL_NUMBER bit is set in dwFlags, the\n serial number string will be returned; if FT_OPEN_BY_DESCRIPTION bit is set in dwFlags, the product\n description string will be returned; if FT_OPEN_BY_LOCATION bit is set in dwFlags, the Location ID will\n be returned; if none of these bits is set, the serial number string will be returned by default.\n @n It can be used to return device string information for a single device. If FT_LIST_BY_INDEX and\n FT_OPEN_BY_SERIAL_NUMBER or FT_OPEN_BY_DESCRIPTION bits are set in dwFlags, the parameter\n pvArg1 is interpreted as the index of the device, and the parameter pvArg2 is interpreted as a pointer to\n a buffer to contain the appropriate string. Indexes are zero-based, and the error code\n FT_DEVICE_NOT_FOUND is returned for an invalid index.\n @n It can be used to return device string information for all connected devices. If FT_LIST_ALL and\n FT_OPEN_BY_SERIAL_NUMBER or FT_OPEN_BY_DESCRIPTION bits are set in dwFlags, the parameter\n pvArg1 is interpreted as a pointer to an array of pointers to buffers to contain the appropriate strings and\n the parameter pvArg2 is interpreted as a pointer to a DWORD location to store the number of devices\n currently connected. Note that, for pvArg1, the last entry in the array of pointers to buffers should be a\n NULL pointer so the array will contain one more location than the number of devices connected.\n @n The location ID of a device is returned if FT_LIST_BY_INDEX and FT_OPEN_BY_LOCATION bits are set in\n dwFlags. In this case the parameter pvArg1 is interpreted as the index of the device, and the parameter\n pvArg2 is interpreted as a pointer to a variable of type long to contain the location ID. Indexes are\n zerobased, and the error code FT_DEVICE_NOT_FOUND is returned for an invalid index. Please note that\n Windows CE and Linux do not support location IDs.\n @n The location IDs of all connected devices are returned if FT_LIST_ALL and FT_OPEN_BY_LOCATION bits\n are set in dwFlags. In this case, the parameter pvArg1 is interpreted as a pointer to an array of variables\n of type long to contain the location IDs, and the parameter pvArg2 is interpreted as a pointer to a\n DWORD location to store the number of devices currently connected.\n @see FT_CreateDeviceInfoList\n @see FT_GetDeviceInfoList\n @see FT_GetDeviceInfoDetail"]
    pub fn FT_ListDevices(pvArg1: PVOID, pvArg2: PVOID, dwFlags: DWORD) -> FT_STATUS;
}
unsafe extern "C" {
    #[doc = " @noop FT_Open\n @par Supported Operating Systems\n Linux\n Mac OS X (10.4 and later)\n Windows (2000 and later)\n Windows CE (4.2 and later)\n @par Summary\n Open the device and return a handle which will be used for subsequent accesses.\n @param deviceNumber Index of the device to open. Indices are 0 based.\n @param pHandle Pointer to a variable of type FT_HANDLE where the handle will be stored. This handle must\n be used to access the device.\n @return\n FT_OK if successful, otherwise the return value is an FT error code.\n @remarks\n Although this function can be used to open multiple devices by setting iDevice to 0, 1, 2 etc. there is no\n ability to open a specific device. To open named devices, use the function FT_OpenEx.\n @see FT_OpenEx."]
    pub fn FT_Open(deviceNumber: ::std::os::raw::c_int, pHandle: *mut FT_HANDLE) -> FT_STATUS;
}
unsafe extern "C" {
    #[doc = " @noop FT_OpenEx\n @par Supported Operating Systems\n Linux\n Mac OS X (10.4 and later)\n Windows (2000 and later)\n Windows CE (4.2 and later)\n @par Summary\n Open the specified device and return a handle that will be used for subsequent accesses. The device can\n be specified by its serial number, device description or location.\n @n This function can also be used to open multiple devices simultaneously. Multiple devices can be specified\n by serial number, device description or location ID (location information derived from the physical\n location of a device on USB). Location IDs for specific USB ports can be obtained using the utility\n USBView and are given in hexadecimal format. Location IDs for devices connected to a system can be\n obtained by calling FT_GetDeviceInfoList or FT_ListDevices with the appropriate flags.\n @param pvArg1 Pointer to an argument whose type depends on the value of dwFlags.\n It is normally be interpreted as a pointer to a null terminated string.\n @param dwFlags FT_OPEN_BY_SERIAL_NUMBER, FT_OPEN_BY_DESCRIPTION or FT_OPEN_BY_LOCATION.\n @param pHandle Pointer to a variable of type FT_HANDLE where the handle will be\n stored. This handle must be used to access the device.\n @returns\n FT_OK if successful, otherwise the return value is an FT error code.\n @remarks\n The parameter specified in pvArg1 depends on dwFlags: if dwFlags is FT_OPEN_BY_SERIAL_NUMBER,\n pvArg1 is interpreted as a pointer to a null-terminated string that represents the serial number of the\n device; if dwFlags is FT_OPEN_BY_DESCRIPTION, pvArg1 is interpreted as a pointer to a nullterminated\n string that represents the device description; if dwFlags is FT_OPEN_BY_LOCATION, pvArg1\n is interpreted as a long value that contains the location ID of the device. Please note that Windows CE\n and Linux do not support location IDs.\n @n ftHandle is a pointer to a variable of type FT_HANDLE where the handle is to be stored. This handle must\n be used to access the device."]
    pub fn FT_OpenEx(pvArg1: PVOID, dwFlags: DWORD, pHandle: *mut FT_HANDLE) -> FT_STATUS;
}
unsafe extern "C" {
    #[doc = " @noop FT_Close\n @par Supported Operating Systems\n Linux\n Mac OS X (10.4 and later)\n Windows (2000 and later)\n Windows CE (4.2 and later)\n @par Summary\n Close an open device.\n @param ftHandle Handle of the device.\n @returns\n FT_OK if successful, otherwise the return value is an FT error code."]
    pub fn FT_Close(ftHandle: FT_HANDLE) -> FT_STATUS;
}
unsafe extern "C" {
    #[doc = " @noop FT_Read\n @par Supported Operating Systems\n Linux\n Mac OS X (10.4 and later)\n Windows (2000 and later)\n Windows CE (4.2 and later)\n @par Summary\n Read data from the device.\n @param ftHandle Handle of the device.\n @param lpBuffer Pointer to the buffer that receives the data from the device.\n @param dwBytesToRead Number of bytes to be read from the device.\n @param lpdwBytesReturned Pointer to a variable of type DWORD which receives the number of\n bytes read from the device.\n @returns\n FT_OK if successful, FT_IO_ERROR otherwise. $see FT_STATUS\n @remarks\n FT_Read always returns the number of bytes read in lpdwBytesReturned.\n @n This function does not return until dwBytesToRead bytes have been read into the buffer. The number of\n bytes in the receive queue can be determined by calling FT_GetStatus or FT_GetQueueStatus, and\n passed to FT_Read as dwBytesToRead so that the function reads the device and returns immediately.\n When a read timeout value has been specified in a previous call to FT_SetTimeouts, FT_Read returns\n when the timer expires or dwBytesToRead have been read, whichever occurs first. If the timeout\n occurred, FT_Read reads available data into the buffer and returns FT_OK.\n @n An application should use the function return value and lpdwBytesReturned when processing the buffer.\n If the return value is FT_OK, and lpdwBytesReturned is equal to dwBytesToRead then FT_Read has\n completed normally. If the return value is FT_OK, and lpdwBytesReturned is less then dwBytesToRead\n then a timeout has occurred and the read has been partially completed. Note that if a timeout occurred\n and no data was read, the return value is still FT_OK.\n @n A return value of FT_IO_ERROR suggests an error in the parameters of the function, or a fatal error like a\n USB disconnect has occurred."]
    pub fn FT_Read(
        ftHandle: FT_HANDLE,
        lpBuffer: LPVOID,
        dwBytesToRead: DWORD,
        lpdwBytesReturned: LPDWORD,
    ) -> FT_STATUS;
}
unsafe extern "C" {
    #[doc = " @noop FT_Write\n @par Supported Operating Systems\n Linux\n Mac OS X (10.4 and later)\n Windows (2000 and later)\n Windows CE (4.2 and later)\n @par Summary\n Write data to the device.\n @param ftHandle Handle of the device.\n @param lpBuffer Pointer to the buffer that contains the data to be written to the device.\n @param dwBytesToWrite Number of bytes to write to the device.\n @param lpdwBytesWritten Pointer to a variable of type DWORD which receives the number of\n bytes written to the device.\n @returns\n FT_OK if successful, otherwise the return value is an FT error code."]
    pub fn FT_Write(
        ftHandle: FT_HANDLE,
        lpBuffer: LPVOID,
        dwBytesToWrite: DWORD,
        lpdwBytesWritten: LPDWORD,
    ) -> FT_STATUS;
}
unsafe extern "C" {
    #[doc = " @noop FT_SetBaudRate\n @par Supported Operating Systems\n Linux\n Mac OS X (10.4 and later)\n Windows (2000 and later)\n Windows CE (4.2 and later)\n @par Summary\n This function sets the baud rate for the device.\n @param ftHandle Handle of the device.\n @param dwBaudRate Baud rate.\n @returns\n FT_OK if successful, otherwise the return value is an FT error code"]
    pub fn FT_SetBaudRate(ftHandle: FT_HANDLE, dwBaudRate: ULONG) -> FT_STATUS;
}
unsafe extern "C" {
    #[doc = " @noop FT_SetDivisor\n @par Supported Operating Systems\n Linux\n Mac OS X (10.4 and later)\n Windows (2000 and later)\n Windows CE (4.2 and later)\n @par Summary\n This function sets the baud rate for the device. It is used to set non-standard baud rates.\n @param ftHandle Handle of the device.\n @param usDivisor Divisor.\n @returns\n FT_OK if successful, otherwise the return value is an FT error code.\n @remarks\n This function is no longer required as FT_SetBaudRate will now automatically calculate the required\n divisor for a requested baud rate. The application note \"Setting baud rates for the FT8U232AM\" is\n available from the Application Notes section of the FTDI website describes how to calculate the divisor for\n a non-standard baud rate."]
    pub fn FT_SetDivisor(ftHandle: FT_HANDLE, usDivisor: USHORT) -> FT_STATUS;
}
unsafe extern "C" {
    #[doc = " @noop FT_SetDataCharacteristics\n @par Supported Operating Systems\n Linux\n Mac OS X (10.4 and later)\n Windows (2000 and later)\n Windows CE (4.2 and later)\n @par Summary\n This function sets the data characteristics for the device.\n @param ftHandle Handle of the device.\n @param uWordLength Number of bits per word - must be FT_BITS_8 or FT_BITS_7.\n @param uStopBits Number of stop bits - must be FT_STOP_BITS_1 or FT_STOP_BITS_2.\n @param uParity Parity - must be FT_PARITY_NONE, FT_PARITY_ODD, FT_PARITY_EVEN,\n FT_PARITY_MARK or FT_PARITY SPACE.\n @returns\n FT_OK if successful, otherwise the return value is an FT error code."]
    pub fn FT_SetDataCharacteristics(
        ftHandle: FT_HANDLE,
        uWordLength: UCHAR,
        uStopBits: UCHAR,
        uParity: UCHAR,
    ) -> FT_STATUS;
}
unsafe extern "C" {
    #[doc = " @noop FT_SetTimeouts\n @par Supported Operating Systems\n Linux\n Mac OS X (10.4 and later)\n Windows (2000 and later)\n Windows CE (4.2 and later)\n @par Summary\n This function sets the read and write timeouts for the device.\n @param ftHandle Handle of the device.\n @param dwReadTimeout Read timeout in milliseconds.\n @param dwWriteTimeout Write timeout in milliseconds.\n @returns\n FT_OK if successful, otherwise the return value is an FT error code."]
    pub fn FT_SetTimeouts(
        ftHandle: FT_HANDLE,
        dwReadTimeout: ULONG,
        dwWriteTimeout: ULONG,
    ) -> FT_STATUS;
}
unsafe extern "C" {
    #[doc = " @noop FT_SetFlowControl\n @par Supported Operating Systems\n Linux\n Mac OS X (10.4 and later)\n Windows (2000 and later)\n Windows CE (4.2 and later)\n @par Summary\n This function sets the flow control for the device.\n @param ftHandle Handle of the device.\n @param usFlowControl Must be one of FT_FLOW_NONE, FT_FLOW_RTS_CTS, FT_FLOW_DTR_DSR or\n FT_FLOW_XON_XOFF.\n @param uXonChar Character used to signal Xon. Only used if flow control is FT_FLOW_XON_XOFF.\n @param uXoffChar Character used to signal Xoff. Only used if flow control is\tFT_FLOW_XON_XOFF.\n @returns\n FT_OK if successful, otherwise the return value is an FT error code."]
    pub fn FT_SetFlowControl(
        ftHandle: FT_HANDLE,
        usFlowControl: USHORT,
        uXonChar: UCHAR,
        uXoffChar: UCHAR,
    ) -> FT_STATUS;
}
unsafe extern "C" {
    #[doc = " @noop FT_SetDtr\n @par Supported Operating Systems\n Linux\n Mac OS X (10.4 and later)\n Windows (2000 and later)\n Windows CE (4.2 and later)\n @par Summary\n This function sets the Data Terminal Ready (DTR) control signal.\n @param ftHandle Handle of the device.\n @returns\n FT_OK if successful, otherwise the return value is an FT error code.\n @remarks\n This function asserts the Data Terminal Ready (DTR) line of the device."]
    pub fn FT_SetDtr(ftHandle: FT_HANDLE) -> FT_STATUS;
}
unsafe extern "C" {
    #[doc = " @noop FT_ClrDtr\n @par Supported Operating Systems\n Linux\n Mac OS X (10.4 and later)\n Windows (2000 and later)\n Windows CE (4.2 and later)\n @par Summary\n This function clears the Data Terminal Ready (DTR) control signal.\n @param ftHandle Handle of the device.\n @returns\n FT_OK if successful, otherwise the return value is an FT error code.\n @remarks\n This function de-asserts the Data Terminal Ready (DTR) line of the device."]
    pub fn FT_ClrDtr(ftHandle: FT_HANDLE) -> FT_STATUS;
}
unsafe extern "C" {
    #[doc = " @noop FT_SetRts\n @par Supported Operating Systems\n Linux\n Mac OS X (10.4 and later)\n Windows (2000 and later)\n Windows CE (4.2 and later)\n @par Summary\n This function sets the Request To Send (RTS) control signal.\n @param ftHandle Handle of the device.\n @returns\n FT_OK if successful, otherwise the return value is an FT error code.\n @remarks\n This function asserts the Request To Send (RTS) line of the device."]
    pub fn FT_SetRts(ftHandle: FT_HANDLE) -> FT_STATUS;
}
unsafe extern "C" {
    #[doc = " @noop FT_ClrRts\n @par Supported Operating Systems\n Linux\n Mac OS X (10.4 and later)\n Windows (2000 and later)\n Windows CE (4.2 and later)\n @par Summary\n This function clears the Request To Send (RTS) control signal.\n @param ftHandle Handle of the device.\n @returns\n FT_OK if successful, otherwise the return value is an FT error code.\n @remarks\n This function de-asserts the Request To Send (RTS) line of the device."]
    pub fn FT_ClrRts(ftHandle: FT_HANDLE) -> FT_STATUS;
}
unsafe extern "C" {
    #[doc = " @noop FT_GetModemStatus\n @par Supported Operating Systems\n Linux\n Mac OS X (10.4 and later)\n Windows (2000 and later)\n Windows CE (4.2 and later)\n @par Summary\n Gets the modem status and line status from the device.\n @param ftHandle Handle of the device.\n @param lpdwModemStatus Pointer to a variable of type DWORD which receives the modem\n status and line status from the device.\n @returns\n FT_OK if successful, otherwise the return value is an FT error code.\n @remarks\n The least significant byte of the lpdwModemStatus value holds the modem status. On Windows and\n Windows CE, the line status is held in the second least significant byte of the lpdwModemStatus value.\n @n The modem status is bit-mapped as follows: Clear To Send (CTS) = 0x10, Data Set Ready (DSR) = 0x20,\n Ring Indicator (RI) = 0x40, Data Carrier Detect (DCD) = 0x80.\n @n The line status is bit-mapped as follows: Overrun Error (OE) = 0x02, Parity Error (PE) = 0x04, Framing\n Error (FE) = 0x08, Break Interrupt (BI) = 0x10."]
    pub fn FT_GetModemStatus(ftHandle: FT_HANDLE, lpdwModemStatus: *mut ULONG) -> FT_STATUS;
}
unsafe extern "C" {
    #[doc = " @noop FT_GetQueueStatus\n @par Supported Operating Systems\n Linux\n Mac OS X (10.4 and later)\n Windows (2000 and later)\n Windows CE (4.2 and later)\n @par Summary\n Gets the number of bytes in the receive queue.\n @param ftHandle Handle of the device.\n @param lpdwAmountInRxQueue Pointer to a variable of type DWORD which receives the number of\n bytes in the receive queue.\n @returns\n FT_OK if successful, otherwise the return value is an FT error code."]
    pub fn FT_GetQueueStatus(ftHandle: FT_HANDLE, lpdwAmountInRxQueue: *mut DWORD) -> FT_STATUS;
}
unsafe extern "C" {
    #[doc = " @noop FT_GetDeviceInfo\n @par Supported Operating Systems\n Linux\n Mac OS X (10.4 and later)\n Windows (2000 and later)\n Windows CE (4.2 and later)\n @par Summary\n Get device information for an open device.\n @param ftHandle Handle of the device.\n @param lpftDevice Pointer to unsigned long to store device type.\n @param lpdwID Pointer to unsigned long to store device ID.\n @param pcSerialNumber Pointer to buffer to store device serial number as a nullterminated string.\n @param pcDescription Pointer to buffer to store device description as a null-terminated string.\n @param pvDummy Reserved for future use - should be set to NULL.\n @returns\n FT_OK if successful, otherwise the return value is an FT error code.\n @remarks\n This function is used to return the device type, device ID, device description and serial number.\n The device ID is encoded in a DWORD - the most significant word contains the vendor ID, and the least\n significant word contains the product ID. So the returned ID 0x04036001 corresponds to the device ID\n VID_0403&PID_6001."]
    pub fn FT_GetDeviceInfo(
        ftHandle: FT_HANDLE,
        lpftDevice: *mut FT_DEVICE,
        lpdwID: LPDWORD,
        pcSerialNumber: PCHAR,
        pcDescription: PCHAR,
        pvDummy: LPVOID,
    ) -> FT_STATUS;
}
unsafe extern "C" {
    #[doc = " @note Extra function for non-Windows platforms to compensate for lack of .INF file to specify Vendor and Product IDs."]
    pub fn FT_GetDeviceLocId(ftHandle: FT_HANDLE, lpdwLocId: LPDWORD) -> FT_STATUS;
}
unsafe extern "C" {
    #[doc = " @noop FT_GetDriverVersion\n @par Supported Operating Systems\n Windows (2000 and later)\n Windows CE (4.2 and later)\n @par Summary\n This function returns the D2XX driver version number.\n @param ftHandle Handle of the device.\n @param lpdwDriverVersion Pointer to the driver version number.\n @returns\n FT_OK if successful, otherwise the return value is an FT error code.\n @remarks\n A version number consists of major, minor and build version numbers contained in a 4-byte field\n (unsigned long). Byte0 (least significant) holds the build version, Byte1 holds the minor version, and\n Byte2 holds the major version. Byte3 is currently set to zero.\n @n For example, driver version \"2.04.06\" is represented as 0x00020406. Note that a device has to be\n opened before this function can be called."]
    pub fn FT_GetDriverVersion(ftHandle: FT_HANDLE, lpdwDriverVersion: LPDWORD) -> FT_STATUS;
}
unsafe extern "C" {
    #[doc = " @noop FT_GetLibraryVersion\n @par Supported Operating Systems\n Linux\n Mac OS X (10.4 and later)\n Windows (2000 and later)\n Windows CE (4.2 and later)\n @n\n This function returns D2XX DLL or library version number.\n @param lpdwDLLVersion Pointer to the DLL or library version number.\n @returns\n FT_OK if successful, otherwise the return value is an FT error code.\n @remarks\n A version number consists of major, minor and build version numbers contained in a 4-byte field\n (unsigned long). Byte0 (least significant) holds the build version, Byte1 holds the minor version, and\n Byte2 holds the major version. Byte3 is currently set to zero.\n @n For example, D2XX DLL version \"3.01.15\" is represented as 0x00030115. Note that this function does\n not take a handle, and so it can be called without opening a device."]
    pub fn FT_GetLibraryVersion(lpdwDLLVersion: LPDWORD) -> FT_STATUS;
}
unsafe extern "C" {
    #[doc = " @noop FT_GetComPortNumber\n @par Supported Operating Systems\n Windows (2000 and later)\n @par Summary\n Retrieves the COM port associated with a device.\n @param ftHandle Handle of the device.\n @param lplComPortNumber Pointer to a variable of type LONG which receives the COM port number\n associated with the device.\n @returns\n FT_OK if successful, otherwise the return value is an FT error code.\n @remarks\n This function is only available when using the Windows CDM driver as both the D2XX and VCP drivers can\n be installed at the same time.\n @n If no COM port is associated with the device, lplComPortNumber will have a value of -1"]
    pub fn FT_GetComPortNumber(ftHandle: FT_HANDLE, lplComPortNumber: LPLONG) -> FT_STATUS;
}
unsafe extern "C" {
    #[doc = " @noop FT_GetStatus\n @par Supported Operating Systems\n Linux\n Mac OS X (10.4 and later)\n Windows (2000 and later)\n Windows CE (4.2 and later)\n @par Summary\n Gets the device status including number of characters in the receive queue, number of characters in the\n transmit queue, and the current event status.\n @param ftHandle Handle of the device.\n @param lpdwAmountInRxQueue Pointer to a variable of type DWORD which receives the number of characters in\n the receive queue.\n @param lpdwAmountInTxQueue Pointer to a variable of type DWORD which receives the number of characters in\n the transmit queue.\n @param lpdwEventStatus Pointer to a variable of type DWORD which receives the current state of\n the event status.\n @returns\n FT_OK if successful, otherwise the return value is an FT error code.\n @remarks\n For an example of how to use this function, see the sample code in FT_SetEventNotification."]
    pub fn FT_GetStatus(
        ftHandle: FT_HANDLE,
        lpdwAmountInRxQueue: *mut DWORD,
        lpdwAmountInTxQueue: *mut DWORD,
        lpdwEventStatus: *mut DWORD,
    ) -> FT_STATUS;
}
unsafe extern "C" {
    #[doc = " @noop FT_SetEventNotification\n @par Supported Operating Systems\n Linux\n Mac OS X (10.4 and later)\n Windows (2000 and later)\n Windows CE (4.2 and later)\n @par Summary\n Sets conditions for event notification.\n @param ftHandle Handle of the device.\n @param dwEventMask Conditions that cause the event to be set.\n @param pvArg Interpreted as the handle of an event.\n @returns\n FT_OK if successful, otherwise the return value is an FT error code.\n @remarks\n An application can use this function to setup conditions which allow a thread to block until one of the\n conditions is met. Typically, an application will create an event, call this function, then block on the\n event. When the conditions are met, the event is set, and the application thread unblocked.\n dwEventMask is a bit-map that describes the events the application is interested in. pvArg is interpreted\n as the handle of an event which has been created by the application. If one of the event conditions is\n met, the event is set.\n @n If FT_EVENT_RXCHAR is set in dwEventMask, the event will be set when a character has been received\n by the device.\n @n If FT_EVENT_MODEM_STATUS is set in dwEventMask, the event will be set when a change in the modem\n signals has been detected by the device.\n @n If FT_EVENT_LINE_STATUS is set in dwEventMask, the event will be set when a change in the line status\n has been detected by the device."]
    pub fn FT_SetEventNotification(
        ftHandle: FT_HANDLE,
        dwEventMask: DWORD,
        pvArg: PVOID,
    ) -> FT_STATUS;
}
unsafe extern "C" {
    #[doc = " @noop FT_SetChars\n @par Supported Operating Systems\n Linux\n Mac OS X (10.4 and later)\n Windows (2000 and later)\n Windows CE (4.2 and later)\n @par Summary\n This function sets the special characters for the device.\n @param ftHandle Handle of the device.\n @param uEventChar Event character.\n @param uEventCharEnabled 0 if event character disabled, non-zero otherwise.\n @param uErrorChar Error character.\n @param uErrorCharEnabled 0 if error character disabled, non-zero otherwise.\n @returns\n FT_OK if successful, otherwise the return value is an FT error code.\n @remarks\n This function allows for inserting specified characters in the data stream to represent events firing or\n errors occurring."]
    pub fn FT_SetChars(
        ftHandle: FT_HANDLE,
        uEventChar: UCHAR,
        uEventCharEnabled: UCHAR,
        uErrorChar: UCHAR,
        uErrorCharEnabled: UCHAR,
    ) -> FT_STATUS;
}
unsafe extern "C" {
    #[doc = " @noop FT_SetBreakOn\n @par Supported Operating Systems\n Linux\n Mac OS X (10.4 and later)\n Windows (2000 and later)\n Windows CE (4.2 and later)\n @par Summary\n Sets the BREAK condition for the device.\n @param ftHandle Handle of the device.\n @returns\n FT_OK if successful, otherwise the return value is an FT error code"]
    pub fn FT_SetBreakOn(ftHandle: FT_HANDLE) -> FT_STATUS;
}
unsafe extern "C" {
    #[doc = " @noop FT_SetBreakOff\n @par Supported Operating Systems\n Linux\n Mac OS X (10.4 and later)\n Windows (2000 and later)\n Windows CE (4.2 and later)\n @par Summary\n Resets the BREAK condition for the device.\n @param ftHandle Handle of the device.\n @returns\n FT_OK if successful, otherwise the return value is an FT error code."]
    pub fn FT_SetBreakOff(ftHandle: FT_HANDLE) -> FT_STATUS;
}
unsafe extern "C" {
    #[doc = " @noop FT_Purge\n @par Supported Operating Systems\n Linux\n Mac OS X (10.4 and later)\n Windows (2000 and later)\n Windows CE (4.2 and later)\n @par Summary\n This function purges receive and transmit buffers in the device.\n @param ftHandle Handle of the device.\n @param ulMask Combination of FT_PURGE_RX and FT_PURGE_TX.\n @returns\n FT_OK if successful, otherwise the return value is an FT error code."]
    pub fn FT_Purge(ftHandle: FT_HANDLE, ulMask: ULONG) -> FT_STATUS;
}
unsafe extern "C" {
    #[doc = " @noop FT_ResetDevice\n @par Supported Operating Systems\n Linux\n Mac OS X (10.4 and later)\n Windows (2000 and later)\n Windows CE (4.2 and later)\n @par Summary\n This function sends a reset command to the device.\n @param ftHandle Handle of the device.\n @returns\n FT_OK if successful, otherwise the return value is an FT error code."]
    pub fn FT_ResetDevice(ftHandle: FT_HANDLE) -> FT_STATUS;
}
unsafe extern "C" {
    #[doc = " @noop FT_ResetPort\n @par Supported Operating Systems\n Windows (2000 and later)\n @par Summary\n Send a reset command to the port.\n @param ftHandle Handle of the device.\n @returns\n FT_OK if successful, otherwise the return value is an FT error code.\n @remarks\n This function is used to attempt to recover the port after a failure. It is not equivalent\n to an unplug-replug event. For the equivalent of an unplug-replug event, use FT_CyclePort.\n @see FT_CyclePort"]
    pub fn FT_ResetPort(ftHandle: FT_HANDLE) -> FT_STATUS;
}
unsafe extern "C" {
    #[doc = " @noop FT_CyclePort\n @par Supported Operating Systems\n Windows (2000 and later)\n @par Summary\n Send a cycle command to the USB port.\n @param ftHandle Handle of the device.\n @returns\n FT_OK if successful, otherwise the return value is an FT error code.\n @remarks\n The effect of this function is the same as disconnecting then reconnecting the device from\n USB. Possible use of this function is situations where a fatal error has occurred and it is\n difficult, or not possible, to recover without unplugging and replugging the USB cable.\n This function can also be used after reprogramming the EEPROM to force the FTDI device to\n read the new EEPROM contents which would\totherwise require a physical disconnect-reconnect.\n @n As the current session is not restored when the driver is reloaded, the application must\n be able to recover after calling this function. It is ithe responisbility of the application\n to close the handle after successfully calling FT_CyclePort.\n @n For FT4232H, FT2232H and FT2232 devices, FT_CyclePort will only work under Windows XP and later."]
    pub fn FT_CyclePort(ftHandle: FT_HANDLE) -> FT_STATUS;
}
unsafe extern "C" {
    #[doc = " @noop FT_Rescan\n @par Supported Operating Systems\n Windows (2000 and later)\n @par Summary\n This function can be of use when trying to recover devices programatically.\n @returns\n FT_OK if successful, otherwise the return value is an FT error code.\n @remarks\n Calling FT_Rescan is equivalent to clicking the \"Scan for hardware changes\" button in the Device\n Manager. Only USB hardware is checked for new devices. All USB devices are scanned, not just FTDI\n devices."]
    pub fn FT_Rescan() -> FT_STATUS;
}
unsafe extern "C" {
    #[doc = " @noop FT_Reload\n @par Supported Operating Systems\n Windows (2000 and later)\n @par Summary\n This function forces a reload of the driver for devices with a specific VID and PID combination.\n @param wVID Vendor ID of the devices to reload the driver for.\n @param wPID Product ID of the devices to reload the driver for.\n @returns\n FT_OK if successful, otherwise the return value is an FT error code.\n @remarks\n Calling FT_Reload forces the operating system to unload and reload the driver for the specified device\n IDs. If the VID and PID parameters are null, the drivers for USB root hubs will be reloaded, causing all\n USB devices connected to reload their drivers. Please note that this function will not work correctly on\n 64-bit Windows when called from a 32-bit application."]
    pub fn FT_Reload(wVID: WORD, wPID: WORD) -> FT_STATUS;
}
unsafe extern "C" {
    #[doc = " @noop FT_SetResetPipeRetryCount\n @par Supported Operating Systems\n Windows (2000 and later)\n Windows CE (4.2 and later)\n @par Summary\n Set the ResetPipeRetryCount value.\n @param ftHandle Handle of the device.\n @param dwCount Unsigned long containing required ResetPipeRetryCount.\n @returns\n FT_OK if successful, otherwise the return value is an FT error code.\n @remarks\n This function is used to set the ResetPipeRetryCount. ResetPipeRetryCount controls the maximum\n number of times that the driver tries to reset a pipe on which an error has occurred.\n ResetPipeRequestRetryCount defaults to 50. It may be necessary to increase this value in noisy\n environments where a lot of USB errors occur."]
    pub fn FT_SetResetPipeRetryCount(ftHandle: FT_HANDLE, dwCount: DWORD) -> FT_STATUS;
}
unsafe extern "C" {
    #[doc = " @noop FT_StopInTask\n @par Supported Operating Systems\n Linux\n Mac OS X (10.4 and later)\n Windows (2000 and later)\n Windows CE (4.2 and later)\n @par Summary\n Stops the driver's IN task.\n @param ftHandle Handle of the device.\n @returns\n FT_OK if successful, otherwise the return value is an FT error code.\n @remarks\n This function is used to put the driver's IN task (read) into a wait state. It can be used in situations\n where data is being received continuously, so that the device can be purged without more data being\n received. It is used together with FT_RestartInTask which sets the IN task running again.\n @see FT_RestartInTask"]
    pub fn FT_StopInTask(ftHandle: FT_HANDLE) -> FT_STATUS;
}
unsafe extern "C" {
    #[doc = " @noop FT_RestartInTask\n @par Supported Operating Systems\n Linux\n Mac OS X (10.4 and later)\n Windows (2000 and later)\n Windows CE (4.2 and later)\n @par Summary\n Restart the driver's IN task.\n @param ftHandle Handle of the device.\n @returns\n FT_OK if successful, otherwise the return value is an FT error code.\n @remarks\n This function is used to restart the driver's IN task (read) after it has been stopped by a call to\n FT_StopInTask.\n @see FT_StopInTask"]
    pub fn FT_RestartInTask(ftHandle: FT_HANDLE) -> FT_STATUS;
}
unsafe extern "C" {
    #[doc = " @noop FT_SetDeadmanTimeout\n @par Supported Operating Systems\n Linux\n Mac OS X (10.4 and later)\n Windows (2000 and later)\n Windows CE (4.2 and later)\n @par Summary\n This function allows the maximum time in milliseconds that a USB request can remain outstanding to\n be set.\n @param ftHandle Handle of the device.\n @param ulDeadmanTimeout Deadman timeout value in milliseconds. Default value is 5000.\n @returns\n FT_OK if successful, otherwise the return value is an FT error code.\n @remarks\n The deadman timeout is referred to in application note AN232B-10 Advanced Driver Options from the\n FTDI web site as the USB timeout. It is unlikely that this function will be required by most users."]
    pub fn FT_SetDeadmanTimeout(ftHandle: FT_HANDLE, ulDeadmanTimeout: ULONG) -> FT_STATUS;
}
unsafe extern "C" {
    #[doc = " @noop FT_IoCtl\n Undocumented function."]
    pub fn FT_IoCtl(
        ftHandle: FT_HANDLE,
        dwIoControlCode: DWORD,
        lpInBuf: LPVOID,
        nInBufSize: DWORD,
        lpOutBuf: LPVOID,
        nOutBufSize: DWORD,
        lpBytesReturned: LPDWORD,
        lpOverlapped: LPOVERLAPPED,
    ) -> FT_STATUS;
}
unsafe extern "C" {
    #[doc = " @noop FT_SetWaitMask\n Undocumented function."]
    pub fn FT_SetWaitMask(ftHandle: FT_HANDLE, Mask: DWORD) -> FT_STATUS;
}
unsafe extern "C" {
    #[doc = " @noop FT_WaitOnMask\n Undocumented function."]
    pub fn FT_WaitOnMask(ftHandle: FT_HANDLE, Mask: *mut DWORD) -> FT_STATUS;
}
unsafe extern "C" {
    #[doc = " @noop FT_GetEventStatus\n Undocumented function."]
    pub fn FT_GetEventStatus(ftHandle: FT_HANDLE, dwEventDWord: *mut DWORD) -> FT_STATUS;
}
unsafe extern "C" {
    #[doc = " @noop FT_ReadEE\n @par Supported Operating Systems\n Linux\n Mac OS X (10.4 and later)\n Windows (2000 and later)\n Windows CE (4.2 and later)\n @par Summary\n Read a value from an EEPROM location.\n @param ftHandle Handle of the device.\n @param dwWordOffset EEPROM location to read from.\n @param lpwValue Pointer to the WORD value read from the EEPROM.\n @returns\n FT_OK if successful, otherwise the return value is an FT error code.\n @remarks\n EEPROMs for FTDI devices are organised by WORD, so each value returned is 16-bits wide."]
    pub fn FT_ReadEE(ftHandle: FT_HANDLE, dwWordOffset: DWORD, lpwValue: LPWORD) -> FT_STATUS;
}
unsafe extern "C" {
    #[doc = " @noop FT_WriteEE\n @par Supported Operating Systems\n Linux\n Mac OS X (10.4 and later)\n Windows (2000 and later)\n Windows CE (4.2 and later)\n @par Summary\n Write a value to an EEPROM location.\n @param ftHandle Handle of the device.\n @param dwWordOffset EEPROM location to read from.\n @param wValue The WORD value write to the EEPROM.\n @returns\n FT_OK if successful, otherwise the return value is an FT error code.\n @remarks\n EEPROMs for FTDI devices are organised by WORD, so each value written to the EEPROM is\n 16-bits wide."]
    pub fn FT_WriteEE(ftHandle: FT_HANDLE, dwWordOffset: DWORD, wValue: WORD) -> FT_STATUS;
}
unsafe extern "C" {
    #[doc = " @noop FT_EraseEE\n @par Supported Operating Systems\n Linux\n Mac OS X (10.4 and later)\n Windows (2000 and later)\n Windows CE (4.2 and later)\n @par Summary\n Erases the device EEPROM.\n @param ftHandle Handle of the device.\n @returns\n FT_OK if successful, otherwise the return value is an FT error code.\n @remarks\n This function will erase the entire contents of an EEPROM, including the user area.\n Note that the FT232R\tand FT245R devices have an internal EEPROM that cannot be erased."]
    pub fn FT_EraseEE(ftHandle: FT_HANDLE) -> FT_STATUS;
}
#[doc = " Structure to hold program data for FT_EE_Program, FT_EE_ProgramEx, FT_EE_Read\n and FT_EE_ReadEx functions.\n @see FT_EE_Read\n @see FT_EE_ReadEx\n @see FT_EE_Program\n @see FT_EE_ProgramEx"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ft_program_data {
    pub Signature1: DWORD,
    #[doc = " Header - must be 0x00000000"]
    pub Signature2: DWORD,
    #[doc = " Header - must be 0xffffffff"]
    pub Version: DWORD,
    #[doc = " Header - FT_PROGRAM_DATA version"]
    pub VendorId: WORD,
    #[doc = " 0x0403"]
    pub ProductId: WORD,
    #[doc = " 0x6001"]
    pub Manufacturer: *mut ::std::os::raw::c_char,
    #[doc = " \"FTDI\""]
    pub ManufacturerId: *mut ::std::os::raw::c_char,
    #[doc = " \"FT\""]
    pub Description: *mut ::std::os::raw::c_char,
    #[doc = " \"USB HS Serial Converter\""]
    pub SerialNumber: *mut ::std::os::raw::c_char,
    #[doc = " \"FT000001\" if fixed, or NULL"]
    pub MaxPower: WORD,
    #[doc = " 0 < MaxPower <= 500"]
    pub PnP: WORD,
    #[doc = " 0 = disabled, 1 = enabled"]
    pub SelfPowered: WORD,
    #[doc = " 0 = bus powered, 1 = self powered"]
    pub RemoteWakeup: WORD,
    #[doc = " 0 = not capable, 1 = capable\n Rev4 (FT232B) extensions"]
    pub Rev4: UCHAR,
    #[doc = " non-zero if Rev4 chip, zero otherwise"]
    pub IsoIn: UCHAR,
    #[doc = " non-zero if in endpoint is isochronous"]
    pub IsoOut: UCHAR,
    #[doc = " non-zero if out endpoint is isochronous"]
    pub PullDownEnable: UCHAR,
    #[doc = " non-zero if pull down enabled"]
    pub SerNumEnable: UCHAR,
    #[doc = " non-zero if serial number to be used"]
    pub USBVersionEnable: UCHAR,
    #[doc = " non-zero if chip uses USBVersion"]
    pub USBVersion: WORD,
    #[doc = " BCD (0x0200 => USB2)\n Rev 5 (FT2232) extensions"]
    pub Rev5: UCHAR,
    #[doc = " non-zero if Rev5 chip, zero otherwise"]
    pub IsoInA: UCHAR,
    #[doc = " non-zero if in endpoint is isochronous"]
    pub IsoInB: UCHAR,
    #[doc = " non-zero if in endpoint is isochronous"]
    pub IsoOutA: UCHAR,
    #[doc = " non-zero if out endpoint is isochronous"]
    pub IsoOutB: UCHAR,
    #[doc = " non-zero if out endpoint is isochronous"]
    pub PullDownEnable5: UCHAR,
    #[doc = " non-zero if pull down enabled"]
    pub SerNumEnable5: UCHAR,
    #[doc = " non-zero if serial number to be used"]
    pub USBVersionEnable5: UCHAR,
    #[doc = " non-zero if chip uses USBVersion"]
    pub USBVersion5: WORD,
    #[doc = " BCD (0x0200 => USB2)"]
    pub AIsHighCurrent: UCHAR,
    #[doc = " non-zero if interface is high current"]
    pub BIsHighCurrent: UCHAR,
    #[doc = " non-zero if interface is high current"]
    pub IFAIsFifo: UCHAR,
    #[doc = " non-zero if interface is 245 FIFO"]
    pub IFAIsFifoTar: UCHAR,
    #[doc = " non-zero if interface is 245 FIFO CPU target"]
    pub IFAIsFastSer: UCHAR,
    #[doc = " non-zero if interface is Fast serial"]
    pub AIsVCP: UCHAR,
    #[doc = " non-zero if interface is to use VCP drivers"]
    pub IFBIsFifo: UCHAR,
    #[doc = " non-zero if interface is 245 FIFO"]
    pub IFBIsFifoTar: UCHAR,
    #[doc = " non-zero if interface is 245 FIFO CPU target"]
    pub IFBIsFastSer: UCHAR,
    #[doc = " non-zero if interface is Fast serial"]
    pub BIsVCP: UCHAR,
    #[doc = " non-zero if interface is to use VCP drivers\n Rev 6 (FT232R) extensions"]
    pub UseExtOsc: UCHAR,
    #[doc = " Use External Oscillator"]
    pub HighDriveIOs: UCHAR,
    #[doc = " High Drive I/Os"]
    pub EndpointSize: UCHAR,
    #[doc = " Endpoint size"]
    pub PullDownEnableR: UCHAR,
    #[doc = " non-zero if pull down enabled"]
    pub SerNumEnableR: UCHAR,
    #[doc = " non-zero if serial number to be used"]
    pub InvertTXD: UCHAR,
    #[doc = " non-zero if invert TXD"]
    pub InvertRXD: UCHAR,
    #[doc = " non-zero if invert RXD"]
    pub InvertRTS: UCHAR,
    #[doc = " non-zero if invert RTS"]
    pub InvertCTS: UCHAR,
    #[doc = " non-zero if invert CTS"]
    pub InvertDTR: UCHAR,
    #[doc = " non-zero if invert DTR"]
    pub InvertDSR: UCHAR,
    #[doc = " non-zero if invert DSR"]
    pub InvertDCD: UCHAR,
    #[doc = " non-zero if invert DCD"]
    pub InvertRI: UCHAR,
    #[doc = " non-zero if invert RI"]
    pub Cbus0: UCHAR,
    #[doc = " Cbus Mux control"]
    pub Cbus1: UCHAR,
    #[doc = " Cbus Mux control"]
    pub Cbus2: UCHAR,
    #[doc = " Cbus Mux control"]
    pub Cbus3: UCHAR,
    #[doc = " Cbus Mux control"]
    pub Cbus4: UCHAR,
    #[doc = " Cbus Mux control"]
    pub RIsD2XX: UCHAR,
    #[doc = " non-zero if using D2XX driver\n Rev 7 (FT2232H) Extensions"]
    pub PullDownEnable7: UCHAR,
    #[doc = " non-zero if pull down enabled"]
    pub SerNumEnable7: UCHAR,
    #[doc = " non-zero if serial number to be used"]
    pub ALSlowSlew: UCHAR,
    #[doc = " non-zero if AL pins have slow slew"]
    pub ALSchmittInput: UCHAR,
    #[doc = " non-zero if AL pins are Schmitt input"]
    pub ALDriveCurrent: UCHAR,
    #[doc = " valid values are 4mA, 8mA, 12mA, 16mA"]
    pub AHSlowSlew: UCHAR,
    #[doc = " non-zero if AH pins have slow slew"]
    pub AHSchmittInput: UCHAR,
    #[doc = " non-zero if AH pins are Schmitt input"]
    pub AHDriveCurrent: UCHAR,
    #[doc = " valid values are 4mA, 8mA, 12mA, 16mA"]
    pub BLSlowSlew: UCHAR,
    #[doc = " non-zero if BL pins have slow slew"]
    pub BLSchmittInput: UCHAR,
    #[doc = " non-zero if BL pins are Schmitt input"]
    pub BLDriveCurrent: UCHAR,
    #[doc = " valid values are 4mA, 8mA, 12mA, 16mA"]
    pub BHSlowSlew: UCHAR,
    #[doc = " non-zero if BH pins have slow slew"]
    pub BHSchmittInput: UCHAR,
    #[doc = " non-zero if BH pins are Schmitt input"]
    pub BHDriveCurrent: UCHAR,
    #[doc = " valid values are 4mA, 8mA, 12mA, 16mA"]
    pub IFAIsFifo7: UCHAR,
    #[doc = " non-zero if interface is 245 FIFO"]
    pub IFAIsFifoTar7: UCHAR,
    #[doc = " non-zero if interface is 245 FIFO CPU target"]
    pub IFAIsFastSer7: UCHAR,
    #[doc = " non-zero if interface is Fast serial"]
    pub AIsVCP7: UCHAR,
    #[doc = " non-zero if interface is to use VCP drivers"]
    pub IFBIsFifo7: UCHAR,
    #[doc = " non-zero if interface is 245 FIFO"]
    pub IFBIsFifoTar7: UCHAR,
    #[doc = " non-zero if interface is 245 FIFO CPU target"]
    pub IFBIsFastSer7: UCHAR,
    #[doc = " non-zero if interface is Fast serial"]
    pub BIsVCP7: UCHAR,
    #[doc = " non-zero if interface is to use VCP drivers"]
    pub PowerSaveEnable: UCHAR,
    #[doc = " non-zero if using BCBUS7 to save power for self-powered designs\n Rev 8 (FT4232H) Extensions"]
    pub PullDownEnable8: UCHAR,
    #[doc = " non-zero if pull down enabled"]
    pub SerNumEnable8: UCHAR,
    #[doc = " non-zero if serial number to be used"]
    pub ASlowSlew: UCHAR,
    #[doc = " non-zero if A pins have slow slew"]
    pub ASchmittInput: UCHAR,
    #[doc = " non-zero if A pins are Schmitt input"]
    pub ADriveCurrent: UCHAR,
    #[doc = " valid values are 4mA, 8mA, 12mA, 16mA"]
    pub BSlowSlew: UCHAR,
    #[doc = " non-zero if B pins have slow slew"]
    pub BSchmittInput: UCHAR,
    #[doc = " non-zero if B pins are Schmitt input"]
    pub BDriveCurrent: UCHAR,
    #[doc = " valid values are 4mA, 8mA, 12mA, 16mA"]
    pub CSlowSlew: UCHAR,
    #[doc = " non-zero if C pins have slow slew"]
    pub CSchmittInput: UCHAR,
    #[doc = " non-zero if C pins are Schmitt input"]
    pub CDriveCurrent: UCHAR,
    #[doc = " valid values are 4mA, 8mA, 12mA, 16mA"]
    pub DSlowSlew: UCHAR,
    #[doc = " non-zero if D pins have slow slew"]
    pub DSchmittInput: UCHAR,
    #[doc = " non-zero if D pins are Schmitt input"]
    pub DDriveCurrent: UCHAR,
    #[doc = " valid values are 4mA, 8mA, 12mA, 16mA"]
    pub ARIIsTXDEN: UCHAR,
    #[doc = " non-zero if port A uses RI as RS485 TXDEN"]
    pub BRIIsTXDEN: UCHAR,
    #[doc = " non-zero if port B uses RI as RS485 TXDEN"]
    pub CRIIsTXDEN: UCHAR,
    #[doc = " non-zero if port C uses RI as RS485 TXDEN"]
    pub DRIIsTXDEN: UCHAR,
    #[doc = " non-zero if port D uses RI as RS485 TXDEN"]
    pub AIsVCP8: UCHAR,
    #[doc = " non-zero if interface is to use VCP drivers"]
    pub BIsVCP8: UCHAR,
    #[doc = " non-zero if interface is to use VCP drivers"]
    pub CIsVCP8: UCHAR,
    #[doc = " non-zero if interface is to use VCP drivers"]
    pub DIsVCP8: UCHAR,
    #[doc = " non-zero if interface is to use VCP drivers\n Rev 9 (FT232H) Extensions"]
    pub PullDownEnableH: UCHAR,
    #[doc = " non-zero if pull down enabled"]
    pub SerNumEnableH: UCHAR,
    #[doc = " non-zero if serial number to be used"]
    pub ACSlowSlewH: UCHAR,
    #[doc = " non-zero if AC pins have slow slew"]
    pub ACSchmittInputH: UCHAR,
    #[doc = " non-zero if AC pins are Schmitt input"]
    pub ACDriveCurrentH: UCHAR,
    #[doc = " valid values are 4mA, 8mA, 12mA, 16mA"]
    pub ADSlowSlewH: UCHAR,
    #[doc = " non-zero if AD pins have slow slew"]
    pub ADSchmittInputH: UCHAR,
    #[doc = " non-zero if AD pins are Schmitt input"]
    pub ADDriveCurrentH: UCHAR,
    #[doc = " valid values are 4mA, 8mA, 12mA, 16mA"]
    pub Cbus0H: UCHAR,
    #[doc = " Cbus Mux control"]
    pub Cbus1H: UCHAR,
    #[doc = " Cbus Mux control"]
    pub Cbus2H: UCHAR,
    #[doc = " Cbus Mux control"]
    pub Cbus3H: UCHAR,
    #[doc = " Cbus Mux control"]
    pub Cbus4H: UCHAR,
    #[doc = " Cbus Mux control"]
    pub Cbus5H: UCHAR,
    #[doc = " Cbus Mux control"]
    pub Cbus6H: UCHAR,
    #[doc = " Cbus Mux control"]
    pub Cbus7H: UCHAR,
    #[doc = " Cbus Mux control"]
    pub Cbus8H: UCHAR,
    #[doc = " Cbus Mux control"]
    pub Cbus9H: UCHAR,
    #[doc = " Cbus Mux control"]
    pub IsFifoH: UCHAR,
    #[doc = " non-zero if interface is 245 FIFO"]
    pub IsFifoTarH: UCHAR,
    #[doc = " non-zero if interface is 245 FIFO CPU target"]
    pub IsFastSerH: UCHAR,
    #[doc = " non-zero if interface is Fast serial"]
    pub IsFT1248H: UCHAR,
    #[doc = " non-zero if interface is FT1248"]
    pub FT1248CpolH: UCHAR,
    #[doc = " FT1248 clock polarity - clock idle high (1) or clock idle low (0)"]
    pub FT1248LsbH: UCHAR,
    #[doc = " FT1248 data is LSB (1) or MSB (0)"]
    pub FT1248FlowControlH: UCHAR,
    #[doc = " FT1248 flow control enable"]
    pub IsVCPH: UCHAR,
    #[doc = " non-zero if interface is to use VCP drivers"]
    pub PowerSaveEnableH: UCHAR,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ft_program_data"][::std::mem::size_of::<ft_program_data>() - 176usize];
    ["Alignment of ft_program_data"][::std::mem::align_of::<ft_program_data>() - 8usize];
    ["Offset of field: ft_program_data::Signature1"]
        [::std::mem::offset_of!(ft_program_data, Signature1) - 0usize];
    ["Offset of field: ft_program_data::Signature2"]
        [::std::mem::offset_of!(ft_program_data, Signature2) - 4usize];
    ["Offset of field: ft_program_data::Version"]
        [::std::mem::offset_of!(ft_program_data, Version) - 8usize];
    ["Offset of field: ft_program_data::VendorId"]
        [::std::mem::offset_of!(ft_program_data, VendorId) - 12usize];
    ["Offset of field: ft_program_data::ProductId"]
        [::std::mem::offset_of!(ft_program_data, ProductId) - 14usize];
    ["Offset of field: ft_program_data::Manufacturer"]
        [::std::mem::offset_of!(ft_program_data, Manufacturer) - 16usize];
    ["Offset of field: ft_program_data::ManufacturerId"]
        [::std::mem::offset_of!(ft_program_data, ManufacturerId) - 24usize];
    ["Offset of field: ft_program_data::Description"]
        [::std::mem::offset_of!(ft_program_data, Description) - 32usize];
    ["Offset of field: ft_program_data::SerialNumber"]
        [::std::mem::offset_of!(ft_program_data, SerialNumber) - 40usize];
    ["Offset of field: ft_program_data::MaxPower"]
        [::std::mem::offset_of!(ft_program_data, MaxPower) - 48usize];
    ["Offset of field: ft_program_data::PnP"]
        [::std::mem::offset_of!(ft_program_data, PnP) - 50usize];
    ["Offset of field: ft_program_data::SelfPowered"]
        [::std::mem::offset_of!(ft_program_data, SelfPowered) - 52usize];
    ["Offset of field: ft_program_data::RemoteWakeup"]
        [::std::mem::offset_of!(ft_program_data, RemoteWakeup) - 54usize];
    ["Offset of field: ft_program_data::Rev4"]
        [::std::mem::offset_of!(ft_program_data, Rev4) - 56usize];
    ["Offset of field: ft_program_data::IsoIn"]
        [::std::mem::offset_of!(ft_program_data, IsoIn) - 57usize];
    ["Offset of field: ft_program_data::IsoOut"]
        [::std::mem::offset_of!(ft_program_data, IsoOut) - 58usize];
    ["Offset of field: ft_program_data::PullDownEnable"]
        [::std::mem::offset_of!(ft_program_data, PullDownEnable) - 59usize];
    ["Offset of field: ft_program_data::SerNumEnable"]
        [::std::mem::offset_of!(ft_program_data, SerNumEnable) - 60usize];
    ["Offset of field: ft_program_data::USBVersionEnable"]
        [::std::mem::offset_of!(ft_program_data, USBVersionEnable) - 61usize];
    ["Offset of field: ft_program_data::USBVersion"]
        [::std::mem::offset_of!(ft_program_data, USBVersion) - 62usize];
    ["Offset of field: ft_program_data::Rev5"]
        [::std::mem::offset_of!(ft_program_data, Rev5) - 64usize];
    ["Offset of field: ft_program_data::IsoInA"]
        [::std::mem::offset_of!(ft_program_data, IsoInA) - 65usize];
    ["Offset of field: ft_program_data::IsoInB"]
        [::std::mem::offset_of!(ft_program_data, IsoInB) - 66usize];
    ["Offset of field: ft_program_data::IsoOutA"]
        [::std::mem::offset_of!(ft_program_data, IsoOutA) - 67usize];
    ["Offset of field: ft_program_data::IsoOutB"]
        [::std::mem::offset_of!(ft_program_data, IsoOutB) - 68usize];
    ["Offset of field: ft_program_data::PullDownEnable5"]
        [::std::mem::offset_of!(ft_program_data, PullDownEnable5) - 69usize];
    ["Offset of field: ft_program_data::SerNumEnable5"]
        [::std::mem::offset_of!(ft_program_data, SerNumEnable5) - 70usize];
    ["Offset of field: ft_program_data::USBVersionEnable5"]
        [::std::mem::offset_of!(ft_program_data, USBVersionEnable5) - 71usize];
    ["Offset of field: ft_program_data::USBVersion5"]
        [::std::mem::offset_of!(ft_program_data, USBVersion5) - 72usize];
    ["Offset of field: ft_program_data::AIsHighCurrent"]
        [::std::mem::offset_of!(ft_program_data, AIsHighCurrent) - 74usize];
    ["Offset of field: ft_program_data::BIsHighCurrent"]
        [::std::mem::offset_of!(ft_program_data, BIsHighCurrent) - 75usize];
    ["Offset of field: ft_program_data::IFAIsFifo"]
        [::std::mem::offset_of!(ft_program_data, IFAIsFifo) - 76usize];
    ["Offset of field: ft_program_data::IFAIsFifoTar"]
        [::std::mem::offset_of!(ft_program_data, IFAIsFifoTar) - 77usize];
    ["Offset of field: ft_program_data::IFAIsFastSer"]
        [::std::mem::offset_of!(ft_program_data, IFAIsFastSer) - 78usize];
    ["Offset of field: ft_program_data::AIsVCP"]
        [::std::mem::offset_of!(ft_program_data, AIsVCP) - 79usize];
    ["Offset of field: ft_program_data::IFBIsFifo"]
        [::std::mem::offset_of!(ft_program_data, IFBIsFifo) - 80usize];
    ["Offset of field: ft_program_data::IFBIsFifoTar"]
        [::std::mem::offset_of!(ft_program_data, IFBIsFifoTar) - 81usize];
    ["Offset of field: ft_program_data::IFBIsFastSer"]
        [::std::mem::offset_of!(ft_program_data, IFBIsFastSer) - 82usize];
    ["Offset of field: ft_program_data::BIsVCP"]
        [::std::mem::offset_of!(ft_program_data, BIsVCP) - 83usize];
    ["Offset of field: ft_program_data::UseExtOsc"]
        [::std::mem::offset_of!(ft_program_data, UseExtOsc) - 84usize];
    ["Offset of field: ft_program_data::HighDriveIOs"]
        [::std::mem::offset_of!(ft_program_data, HighDriveIOs) - 85usize];
    ["Offset of field: ft_program_data::EndpointSize"]
        [::std::mem::offset_of!(ft_program_data, EndpointSize) - 86usize];
    ["Offset of field: ft_program_data::PullDownEnableR"]
        [::std::mem::offset_of!(ft_program_data, PullDownEnableR) - 87usize];
    ["Offset of field: ft_program_data::SerNumEnableR"]
        [::std::mem::offset_of!(ft_program_data, SerNumEnableR) - 88usize];
    ["Offset of field: ft_program_data::InvertTXD"]
        [::std::mem::offset_of!(ft_program_data, InvertTXD) - 89usize];
    ["Offset of field: ft_program_data::InvertRXD"]
        [::std::mem::offset_of!(ft_program_data, InvertRXD) - 90usize];
    ["Offset of field: ft_program_data::InvertRTS"]
        [::std::mem::offset_of!(ft_program_data, InvertRTS) - 91usize];
    ["Offset of field: ft_program_data::InvertCTS"]
        [::std::mem::offset_of!(ft_program_data, InvertCTS) - 92usize];
    ["Offset of field: ft_program_data::InvertDTR"]
        [::std::mem::offset_of!(ft_program_data, InvertDTR) - 93usize];
    ["Offset of field: ft_program_data::InvertDSR"]
        [::std::mem::offset_of!(ft_program_data, InvertDSR) - 94usize];
    ["Offset of field: ft_program_data::InvertDCD"]
        [::std::mem::offset_of!(ft_program_data, InvertDCD) - 95usize];
    ["Offset of field: ft_program_data::InvertRI"]
        [::std::mem::offset_of!(ft_program_data, InvertRI) - 96usize];
    ["Offset of field: ft_program_data::Cbus0"]
        [::std::mem::offset_of!(ft_program_data, Cbus0) - 97usize];
    ["Offset of field: ft_program_data::Cbus1"]
        [::std::mem::offset_of!(ft_program_data, Cbus1) - 98usize];
    ["Offset of field: ft_program_data::Cbus2"]
        [::std::mem::offset_of!(ft_program_data, Cbus2) - 99usize];
    ["Offset of field: ft_program_data::Cbus3"]
        [::std::mem::offset_of!(ft_program_data, Cbus3) - 100usize];
    ["Offset of field: ft_program_data::Cbus4"]
        [::std::mem::offset_of!(ft_program_data, Cbus4) - 101usize];
    ["Offset of field: ft_program_data::RIsD2XX"]
        [::std::mem::offset_of!(ft_program_data, RIsD2XX) - 102usize];
    ["Offset of field: ft_program_data::PullDownEnable7"]
        [::std::mem::offset_of!(ft_program_data, PullDownEnable7) - 103usize];
    ["Offset of field: ft_program_data::SerNumEnable7"]
        [::std::mem::offset_of!(ft_program_data, SerNumEnable7) - 104usize];
    ["Offset of field: ft_program_data::ALSlowSlew"]
        [::std::mem::offset_of!(ft_program_data, ALSlowSlew) - 105usize];
    ["Offset of field: ft_program_data::ALSchmittInput"]
        [::std::mem::offset_of!(ft_program_data, ALSchmittInput) - 106usize];
    ["Offset of field: ft_program_data::ALDriveCurrent"]
        [::std::mem::offset_of!(ft_program_data, ALDriveCurrent) - 107usize];
    ["Offset of field: ft_program_data::AHSlowSlew"]
        [::std::mem::offset_of!(ft_program_data, AHSlowSlew) - 108usize];
    ["Offset of field: ft_program_data::AHSchmittInput"]
        [::std::mem::offset_of!(ft_program_data, AHSchmittInput) - 109usize];
    ["Offset of field: ft_program_data::AHDriveCurrent"]
        [::std::mem::offset_of!(ft_program_data, AHDriveCurrent) - 110usize];
    ["Offset of field: ft_program_data::BLSlowSlew"]
        [::std::mem::offset_of!(ft_program_data, BLSlowSlew) - 111usize];
    ["Offset of field: ft_program_data::BLSchmittInput"]
        [::std::mem::offset_of!(ft_program_data, BLSchmittInput) - 112usize];
    ["Offset of field: ft_program_data::BLDriveCurrent"]
        [::std::mem::offset_of!(ft_program_data, BLDriveCurrent) - 113usize];
    ["Offset of field: ft_program_data::BHSlowSlew"]
        [::std::mem::offset_of!(ft_program_data, BHSlowSlew) - 114usize];
    ["Offset of field: ft_program_data::BHSchmittInput"]
        [::std::mem::offset_of!(ft_program_data, BHSchmittInput) - 115usize];
    ["Offset of field: ft_program_data::BHDriveCurrent"]
        [::std::mem::offset_of!(ft_program_data, BHDriveCurrent) - 116usize];
    ["Offset of field: ft_program_data::IFAIsFifo7"]
        [::std::mem::offset_of!(ft_program_data, IFAIsFifo7) - 117usize];
    ["Offset of field: ft_program_data::IFAIsFifoTar7"]
        [::std::mem::offset_of!(ft_program_data, IFAIsFifoTar7) - 118usize];
    ["Offset of field: ft_program_data::IFAIsFastSer7"]
        [::std::mem::offset_of!(ft_program_data, IFAIsFastSer7) - 119usize];
    ["Offset of field: ft_program_data::AIsVCP7"]
        [::std::mem::offset_of!(ft_program_data, AIsVCP7) - 120usize];
    ["Offset of field: ft_program_data::IFBIsFifo7"]
        [::std::mem::offset_of!(ft_program_data, IFBIsFifo7) - 121usize];
    ["Offset of field: ft_program_data::IFBIsFifoTar7"]
        [::std::mem::offset_of!(ft_program_data, IFBIsFifoTar7) - 122usize];
    ["Offset of field: ft_program_data::IFBIsFastSer7"]
        [::std::mem::offset_of!(ft_program_data, IFBIsFastSer7) - 123usize];
    ["Offset of field: ft_program_data::BIsVCP7"]
        [::std::mem::offset_of!(ft_program_data, BIsVCP7) - 124usize];
    ["Offset of field: ft_program_data::PowerSaveEnable"]
        [::std::mem::offset_of!(ft_program_data, PowerSaveEnable) - 125usize];
    ["Offset of field: ft_program_data::PullDownEnable8"]
        [::std::mem::offset_of!(ft_program_data, PullDownEnable8) - 126usize];
    ["Offset of field: ft_program_data::SerNumEnable8"]
        [::std::mem::offset_of!(ft_program_data, SerNumEnable8) - 127usize];
    ["Offset of field: ft_program_data::ASlowSlew"]
        [::std::mem::offset_of!(ft_program_data, ASlowSlew) - 128usize];
    ["Offset of field: ft_program_data::ASchmittInput"]
        [::std::mem::offset_of!(ft_program_data, ASchmittInput) - 129usize];
    ["Offset of field: ft_program_data::ADriveCurrent"]
        [::std::mem::offset_of!(ft_program_data, ADriveCurrent) - 130usize];
    ["Offset of field: ft_program_data::BSlowSlew"]
        [::std::mem::offset_of!(ft_program_data, BSlowSlew) - 131usize];
    ["Offset of field: ft_program_data::BSchmittInput"]
        [::std::mem::offset_of!(ft_program_data, BSchmittInput) - 132usize];
    ["Offset of field: ft_program_data::BDriveCurrent"]
        [::std::mem::offset_of!(ft_program_data, BDriveCurrent) - 133usize];
    ["Offset of field: ft_program_data::CSlowSlew"]
        [::std::mem::offset_of!(ft_program_data, CSlowSlew) - 134usize];
    ["Offset of field: ft_program_data::CSchmittInput"]
        [::std::mem::offset_of!(ft_program_data, CSchmittInput) - 135usize];
    ["Offset of field: ft_program_data::CDriveCurrent"]
        [::std::mem::offset_of!(ft_program_data, CDriveCurrent) - 136usize];
    ["Offset of field: ft_program_data::DSlowSlew"]
        [::std::mem::offset_of!(ft_program_data, DSlowSlew) - 137usize];
    ["Offset of field: ft_program_data::DSchmittInput"]
        [::std::mem::offset_of!(ft_program_data, DSchmittInput) - 138usize];
    ["Offset of field: ft_program_data::DDriveCurrent"]
        [::std::mem::offset_of!(ft_program_data, DDriveCurrent) - 139usize];
    ["Offset of field: ft_program_data::ARIIsTXDEN"]
        [::std::mem::offset_of!(ft_program_data, ARIIsTXDEN) - 140usize];
    ["Offset of field: ft_program_data::BRIIsTXDEN"]
        [::std::mem::offset_of!(ft_program_data, BRIIsTXDEN) - 141usize];
    ["Offset of field: ft_program_data::CRIIsTXDEN"]
        [::std::mem::offset_of!(ft_program_data, CRIIsTXDEN) - 142usize];
    ["Offset of field: ft_program_data::DRIIsTXDEN"]
        [::std::mem::offset_of!(ft_program_data, DRIIsTXDEN) - 143usize];
    ["Offset of field: ft_program_data::AIsVCP8"]
        [::std::mem::offset_of!(ft_program_data, AIsVCP8) - 144usize];
    ["Offset of field: ft_program_data::BIsVCP8"]
        [::std::mem::offset_of!(ft_program_data, BIsVCP8) - 145usize];
    ["Offset of field: ft_program_data::CIsVCP8"]
        [::std::mem::offset_of!(ft_program_data, CIsVCP8) - 146usize];
    ["Offset of field: ft_program_data::DIsVCP8"]
        [::std::mem::offset_of!(ft_program_data, DIsVCP8) - 147usize];
    ["Offset of field: ft_program_data::PullDownEnableH"]
        [::std::mem::offset_of!(ft_program_data, PullDownEnableH) - 148usize];
    ["Offset of field: ft_program_data::SerNumEnableH"]
        [::std::mem::offset_of!(ft_program_data, SerNumEnableH) - 149usize];
    ["Offset of field: ft_program_data::ACSlowSlewH"]
        [::std::mem::offset_of!(ft_program_data, ACSlowSlewH) - 150usize];
    ["Offset of field: ft_program_data::ACSchmittInputH"]
        [::std::mem::offset_of!(ft_program_data, ACSchmittInputH) - 151usize];
    ["Offset of field: ft_program_data::ACDriveCurrentH"]
        [::std::mem::offset_of!(ft_program_data, ACDriveCurrentH) - 152usize];
    ["Offset of field: ft_program_data::ADSlowSlewH"]
        [::std::mem::offset_of!(ft_program_data, ADSlowSlewH) - 153usize];
    ["Offset of field: ft_program_data::ADSchmittInputH"]
        [::std::mem::offset_of!(ft_program_data, ADSchmittInputH) - 154usize];
    ["Offset of field: ft_program_data::ADDriveCurrentH"]
        [::std::mem::offset_of!(ft_program_data, ADDriveCurrentH) - 155usize];
    ["Offset of field: ft_program_data::Cbus0H"]
        [::std::mem::offset_of!(ft_program_data, Cbus0H) - 156usize];
    ["Offset of field: ft_program_data::Cbus1H"]
        [::std::mem::offset_of!(ft_program_data, Cbus1H) - 157usize];
    ["Offset of field: ft_program_data::Cbus2H"]
        [::std::mem::offset_of!(ft_program_data, Cbus2H) - 158usize];
    ["Offset of field: ft_program_data::Cbus3H"]
        [::std::mem::offset_of!(ft_program_data, Cbus3H) - 159usize];
    ["Offset of field: ft_program_data::Cbus4H"]
        [::std::mem::offset_of!(ft_program_data, Cbus4H) - 160usize];
    ["Offset of field: ft_program_data::Cbus5H"]
        [::std::mem::offset_of!(ft_program_data, Cbus5H) - 161usize];
    ["Offset of field: ft_program_data::Cbus6H"]
        [::std::mem::offset_of!(ft_program_data, Cbus6H) - 162usize];
    ["Offset of field: ft_program_data::Cbus7H"]
        [::std::mem::offset_of!(ft_program_data, Cbus7H) - 163usize];
    ["Offset of field: ft_program_data::Cbus8H"]
        [::std::mem::offset_of!(ft_program_data, Cbus8H) - 164usize];
    ["Offset of field: ft_program_data::Cbus9H"]
        [::std::mem::offset_of!(ft_program_data, Cbus9H) - 165usize];
    ["Offset of field: ft_program_data::IsFifoH"]
        [::std::mem::offset_of!(ft_program_data, IsFifoH) - 166usize];
    ["Offset of field: ft_program_data::IsFifoTarH"]
        [::std::mem::offset_of!(ft_program_data, IsFifoTarH) - 167usize];
    ["Offset of field: ft_program_data::IsFastSerH"]
        [::std::mem::offset_of!(ft_program_data, IsFastSerH) - 168usize];
    ["Offset of field: ft_program_data::IsFT1248H"]
        [::std::mem::offset_of!(ft_program_data, IsFT1248H) - 169usize];
    ["Offset of field: ft_program_data::FT1248CpolH"]
        [::std::mem::offset_of!(ft_program_data, FT1248CpolH) - 170usize];
    ["Offset of field: ft_program_data::FT1248LsbH"]
        [::std::mem::offset_of!(ft_program_data, FT1248LsbH) - 171usize];
    ["Offset of field: ft_program_data::FT1248FlowControlH"]
        [::std::mem::offset_of!(ft_program_data, FT1248FlowControlH) - 172usize];
    ["Offset of field: ft_program_data::IsVCPH"]
        [::std::mem::offset_of!(ft_program_data, IsVCPH) - 173usize];
    ["Offset of field: ft_program_data::PowerSaveEnableH"]
        [::std::mem::offset_of!(ft_program_data, PowerSaveEnableH) - 174usize];
};
impl Default for ft_program_data {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Structure to hold program data for FT_EE_Program, FT_EE_ProgramEx, FT_EE_Read\n and FT_EE_ReadEx functions.\n @see FT_EE_Read\n @see FT_EE_ReadEx\n @see FT_EE_Program\n @see FT_EE_ProgramEx"]
pub type FT_PROGRAM_DATA = ft_program_data;
#[doc = " Structure to hold program data for FT_EE_Program, FT_EE_ProgramEx, FT_EE_Read\n and FT_EE_ReadEx functions.\n @see FT_EE_Read\n @see FT_EE_ReadEx\n @see FT_EE_Program\n @see FT_EE_ProgramEx"]
pub type PFT_PROGRAM_DATA = *mut ft_program_data;
unsafe extern "C" {
    #[doc = " @noop FT_EE_Read\n @par Supported Operating Systems\n Linux\n Mac OS X (10.4 and later)\n Windows (2000 and later)\n Windows CE (4.2 and later)\n @par Summary\n Read the contents of the EEPROM.\n @param ftHandle Handle of the device.\n @param pData Pointer to structure of type FT_PROGRAM_DATA.\n @returns\n FT_OK if successful, otherwise the return value is an FT error code.\n @remarks\n This function interprets the parameter pData as a pointer to a structure of type FT_PROGRAM_DATA\n that contains storage for the data to be read from the EEPROM.\n @n The function does not perform any checks on buffer sizes, so the buffers passed in the\n FT_PROGRAM_DATA structure must be big enough to accommodate their respective strings (including\n null terminators). The sizes shown in the following example are more than adequate and can be rounded\n down if necessary. The restriction is that the Manufacturer string length plus the Description string\n length is less than or equal to 40 characters.\n @note Note that the DLL must be informed which version of the FT_PROGRAM_DATA structure is being used.\n This is done through the Signature1, Signature2 and Version elements of the structure. Signature1\n should always be 0x00000000, Signature2 should always be 0xFFFFFFFF and Version can be set to use\n whichever version is required. For compatibility with all current devices Version should be set to the\n latest version of the FT_PROGRAM_DATA structure which is defined in FTD2XX.h.\n @see FT_PROGRAM_DATA"]
    pub fn FT_EE_Read(ftHandle: FT_HANDLE, pData: PFT_PROGRAM_DATA) -> FT_STATUS;
}
unsafe extern "C" {
    #[doc = " @noop FT_EE_ReadEx\n @par Supported Operating Systems\n Linux\n Mac OS X (10.4 and later)\n Windows (2000 and later)\n Windows CE (4.2 and later)\n @par Summary\n Read the contents of the EEPROM and pass strings separately.\n @param ftHandle Handle of the device.\n @param pData Pointer to structure of type FT_PROGRAM_DATA.\n @param *Manufacturer Pointer to a null-terminated string containing the manufacturer name.\n @param *ManufacturerId Pointer to a null-terminated string containing the manufacturer ID.\n @param *Description Pointer to a null-terminated string containing the device description.\n @param *SerialNumber Pointer to a null-terminated string containing the device serial number.\n @returns\n FT_OK if successful, otherwise the return value is an FT error code.\n @remarks\n This variation of the standard FT_EE_Read function was included to provide support for languages such\n as LabVIEW where problems can occur when string pointers are contained in a structure.\n @n This function interprets the parameter pData as a pointer to a structure of type FT_PROGRAM_DATA that\n contains storage for the data to be read from the EEPROM.\n @n The function does not perform any checks on buffer sizes, so the buffers passed in the\n FT_PROGRAM_DATA structure must be big enough to accommodate their respective strings (including\n null terminators).\n @note Note that the DLL must be informed which version of the FT_PROGRAM_DATA structure is being used.\n This is done through the Signature1, Signature2 and Version elements of the structure. Signature1\n should always be 0x00000000, Signature2 should always be 0xFFFFFFFF and Version can be set to use\n whichever version is required. For compatibility with all current devices Version should be set to the\n latest version of the FT_PROGRAM_DATA structure which is defined in FTD2XX.h.\n @n The string parameters in the FT_PROGRAM_DATA structure should be passed as DWORDs to avoid\n overlapping of parameters. All string pointers are passed out separately from the FT_PROGRAM_DATA\n structure.\n @see FT_PROGRAM_DATA"]
    pub fn FT_EE_ReadEx(
        ftHandle: FT_HANDLE,
        pData: PFT_PROGRAM_DATA,
        Manufacturer: *mut ::std::os::raw::c_char,
        ManufacturerId: *mut ::std::os::raw::c_char,
        Description: *mut ::std::os::raw::c_char,
        SerialNumber: *mut ::std::os::raw::c_char,
    ) -> FT_STATUS;
}
unsafe extern "C" {
    #[doc = " @noop FT_EE_Program\n @par Supported Operating Systems\n Linux\n Mac OS X (10.4 and later)\n Windows (2000 and later)\n Windows CE (4.2 and later)\n @par Summary\n Program the EEPROM.\n @param ftHandle Handle of the device.\n @param pData Pointer to structure of type FT_PROGRAM_DATA.\n @returns\n FT_OK if successful, otherwise the return value is an FT error code.\n @remarks\n This function interprets the parameter pData as a pointer to a structure of type FT_PROGRAM_DATA\n that\tcontains the data to write to the EEPROM. The data is written to EEPROM, then read back and\n verified.\n @n If the SerialNumber field in FT_PROGRAM_DATA is NULL, or SerialNumber points to a NULL string,\n a serial number based on the ManufacturerId and the current date and time will be generated. The\n Manufacturer string length plus the Description string length must be less than or equal to 40\n characters.\n @note Note that the DLL must be informed which version of the FT_PROGRAM_DATA structure is being\n used. This is done through the Signature1, Signature2 and Version elements of the structure.\n Signature1 should always be 0x00000000, Signature2 should always be 0xFFFFFFFF and Version can be\n set to use whichever version is required. For compatibility with all current devices Version\n should be set to the latest version of the FT_PROGRAM_DATA structure which is defined in FTD2XX.h.\n If pData is NULL, the structure version will default to 0 (original BM series) and the device will\n be programmed with the default data.\n @see FT_PROGRAM_DATA"]
    pub fn FT_EE_Program(ftHandle: FT_HANDLE, pData: PFT_PROGRAM_DATA) -> FT_STATUS;
}
unsafe extern "C" {
    #[doc = " @noop FT_EE_ProgramEx\n @par Supported Operating Systems\n Linux\n Mac OS X (10.4 and later)\n Windows (2000 and later)\n Windows CE (4.2 and later)\n @par Summary\n Program the EEPROM and pass strings separately.\n @param ftHandle Handle of the device.\n @param pData Pointer to structure of type FT_PROGRAM_DATA.\n @param *Manufacturer Pointer to a null-terminated string containing the manufacturer name.\n @param *ManufacturerId Pointer to a null-terminated string containing the manufacturer ID.\n @param *Description Pointer to a null-terminated string containing the device description.\n @param *SerialNumber Pointer to a null-terminated string containing the device serial number.\n @returns\n FT_OK if successful, otherwise the return value is an FT error code.\n @remarks\n This variation of the FT_EE_Program function was included to provide support for languages such\n as LabVIEW where problems can occur when string pointers are contained in a structure.\n @n This function interprets the parameter pData as a pointer to a structure of type FT_PROGRAM_DATA\n that contains the data to write to the EEPROM. The data is written to EEPROM, then read back and\n verified. The string pointer parameters in the FT_PROGRAM_DATA structure should be allocated as\n DWORDs to avoid overlapping of parameters. The string parameters are then passed in separately.\n @n If the SerialNumber field is NULL, or SerialNumber points to a NULL string, a serial number based\n on the ManufacturerId and the current date and time will be generated. The Manufacturer string\n length plus the Description string length must be less than or equal to 40 characters.\n @note Note that the DLL must be informed which version of the FT_PROGRAM_DATA structure is being used.\n This is done through the Signature1, Signature2 and Version elements of the structure. Signature1\n should always be 0x00000000, Signature2 should always be 0xFFFFFFFF and Version can be set to use\n whichever version is required. For compatibility with all current devices Version should be set to the\n latest version of the FT_PROGRAM_DATA structure which is defined in FTD2XX.h.\n If pData is NULL, the structure version will default to 0 (original BM series) and the device will be\n programmed with the default data.\n @see FT_PROGRAM_DATA"]
    pub fn FT_EE_ProgramEx(
        ftHandle: FT_HANDLE,
        pData: PFT_PROGRAM_DATA,
        Manufacturer: *mut ::std::os::raw::c_char,
        ManufacturerId: *mut ::std::os::raw::c_char,
        Description: *mut ::std::os::raw::c_char,
        SerialNumber: *mut ::std::os::raw::c_char,
    ) -> FT_STATUS;
}
unsafe extern "C" {
    #[doc = " @noop FT_EE_UASize\n @par Supported Operating Systems\n Linux\n Mac OS X (10.4 and later)\n Windows (2000 and later)\n Windows CE (4.2 and later)\n @par Summary\n Get the available size of the EEPROM user area.\n @param ftHandle Handle of the device.\n @param lpdwSize Pointer to a DWORD that receives the available size, in bytes, of the EEPROM\n user area.\n @returns\n FT_OK if successful, otherwise the return value is an FT error code.\n @remarks\n The user area of an FTDI device EEPROM is the total area of the EEPROM that is unused by device\n configuration information and descriptors. This area is available to the user to store information\n specific\tto their application. The size of the user area depends on the length of the Manufacturer,\n ManufacturerId, Description and SerialNumber strings programmed into the EEPROM."]
    pub fn FT_EE_UASize(ftHandle: FT_HANDLE, lpdwSize: LPDWORD) -> FT_STATUS;
}
unsafe extern "C" {
    #[doc = " @noop FT_EE_UARead\n @par Supported Operating Systems\n Linux\n Mac OS X (10.4 and later)\n Windows (2000 and later)\n Windows CE (4.2 and later)\n @par Summary\n Read the contents of the EEPROM user area.\n @param ftHandle Handle of the device.\n @param pucData Pointer to a buffer that contains storage for data to be read.\n @param dwDataLen Size, in bytes, of buffer that contains storage for the data to be read.\n @param lpdwBytesRead Pointer to a DWORD that receives the number of bytes read.\n @returns\n FT_OK if successful, otherwise the return value is an FT error code.\n @remarks\n This function interprets the parameter pucData as a pointer to an array of bytes of size\n dwDataLen that contains storage for the data to be read from the EEPROM user area. The actual\n number of bytes read is stored in the DWORD referenced by lpdwBytesRead.\n @n If dwDataLen is less than the size of the EEPROM user area, then dwDataLen bytes are read\n into the buffer. Otherwise, the whole of the EEPROM user area is read into the buffer. The\n available user area size can be determined by calling FT_EE_UASize.\n @n An application should check the function return value and lpdwBytesRead when FT_EE_UARead\n returns."]
    pub fn FT_EE_UARead(
        ftHandle: FT_HANDLE,
        pucData: PUCHAR,
        dwDataLen: DWORD,
        lpdwBytesRead: LPDWORD,
    ) -> FT_STATUS;
}
unsafe extern "C" {
    #[doc = " @noop FT_EE_UAWrite\n @par Supported Operating Systems\n Linux\n Mac OS X (10.4 and later)\n Windows (2000 and later)\n Windows CE (4.2 and later)\n @par Summary\n Write data into the EEPROM user area.\n @param ftHandle Handle of the device.\n @param pucData Pointer to a buffer that contains the data to be written.\n @param dwDataLen Size, in bytes, of buffer that contains storage for the data to be read.\n @returns\n FT_OK if successful, otherwise the return value is an FT error code.\n @remarks\n This function interprets the parameter pucData as a pointer to an array of bytes of size\n dwDataLen that contains the data to be written to the EEPROM user area. It is a programming\n error for dwDataLen to be greater than the size of the EEPROM user area. The available user\n area size can be determined by calling FT_EE_UASize."]
    pub fn FT_EE_UAWrite(ftHandle: FT_HANDLE, pucData: PUCHAR, dwDataLen: DWORD) -> FT_STATUS;
}
#[doc = "  @noop FT_EEPROM_HEADER\n @par Summary\n Structure to hold data for FT_EEPROM_Program and FT_EEPROM_Read functions.\n The structure for the command includes one FT_EEPROM_HEADER with a device-specific\n structure appended.\n @see FT_EEPROM_Read\n @see FT_EEPROM_Program"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ft_eeprom_header {
    pub deviceType: FT_DEVICE,
    #[doc = " FTxxxx device type to be programmed\n Device descriptor options"]
    pub VendorId: WORD,
    #[doc = " 0x0403"]
    pub ProductId: WORD,
    #[doc = " 0x6001"]
    pub SerNumEnable: UCHAR,
    #[doc = " non-zero if serial number to be used\n Config descriptor options"]
    pub MaxPower: WORD,
    #[doc = " 0 < MaxPower <= 500"]
    pub SelfPowered: UCHAR,
    #[doc = " 0 = bus powered, 1 = self powered"]
    pub RemoteWakeup: UCHAR,
    #[doc = " 0 = not capable, 1 = capable\n Hardware options"]
    pub PullDownEnable: UCHAR,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ft_eeprom_header"][::std::mem::size_of::<ft_eeprom_header>() - 16usize];
    ["Alignment of ft_eeprom_header"][::std::mem::align_of::<ft_eeprom_header>() - 4usize];
    ["Offset of field: ft_eeprom_header::deviceType"]
        [::std::mem::offset_of!(ft_eeprom_header, deviceType) - 0usize];
    ["Offset of field: ft_eeprom_header::VendorId"]
        [::std::mem::offset_of!(ft_eeprom_header, VendorId) - 4usize];
    ["Offset of field: ft_eeprom_header::ProductId"]
        [::std::mem::offset_of!(ft_eeprom_header, ProductId) - 6usize];
    ["Offset of field: ft_eeprom_header::SerNumEnable"]
        [::std::mem::offset_of!(ft_eeprom_header, SerNumEnable) - 8usize];
    ["Offset of field: ft_eeprom_header::MaxPower"]
        [::std::mem::offset_of!(ft_eeprom_header, MaxPower) - 10usize];
    ["Offset of field: ft_eeprom_header::SelfPowered"]
        [::std::mem::offset_of!(ft_eeprom_header, SelfPowered) - 12usize];
    ["Offset of field: ft_eeprom_header::RemoteWakeup"]
        [::std::mem::offset_of!(ft_eeprom_header, RemoteWakeup) - 13usize];
    ["Offset of field: ft_eeprom_header::PullDownEnable"]
        [::std::mem::offset_of!(ft_eeprom_header, PullDownEnable) - 14usize];
};
#[doc = "  @noop FT_EEPROM_HEADER\n @par Summary\n Structure to hold data for FT_EEPROM_Program and FT_EEPROM_Read functions.\n The structure for the command includes one FT_EEPROM_HEADER with a device-specific\n structure appended.\n @see FT_EEPROM_Read\n @see FT_EEPROM_Program"]
pub type FT_EEPROM_HEADER = ft_eeprom_header;
#[doc = "  @noop FT_EEPROM_232B\n @par Summary\n Structure to hold data for the FT232B data in the FT_EEPROM_Program and FT_EEPROM_Read functions.\n This is appended to an FT_EEPROM_HEADER structure.\n @see FT_EEPROM_HEADER"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ft_eeprom_232b {
    #[doc = " Common header"]
    pub common: FT_EEPROM_HEADER,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ft_eeprom_232b"][::std::mem::size_of::<ft_eeprom_232b>() - 16usize];
    ["Alignment of ft_eeprom_232b"][::std::mem::align_of::<ft_eeprom_232b>() - 4usize];
    ["Offset of field: ft_eeprom_232b::common"]
        [::std::mem::offset_of!(ft_eeprom_232b, common) - 0usize];
};
#[doc = "  @noop FT_EEPROM_232B\n @par Summary\n Structure to hold data for the FT232B data in the FT_EEPROM_Program and FT_EEPROM_Read functions.\n This is appended to an FT_EEPROM_HEADER structure.\n @see FT_EEPROM_HEADER"]
pub type FT_EEPROM_232B = ft_eeprom_232b;
#[doc = "  @noop FT_EEPROM_2232\n @par Summary\n Structure to hold data for the FT2232C, FT2232D and FT2232L data in the FT_EEPROM_Program\n and FT_EEPROM_Read functions.\n This is appended to an FT_EEPROM_HEADER structure.\n @see FT_EEPROM_HEADER"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ft_eeprom_2232 {
    #[doc = " Common header"]
    pub common: FT_EEPROM_HEADER,
    #[doc = " common elements for all device EEPROMs\n Drive options"]
    pub AIsHighCurrent: UCHAR,
    #[doc = " non-zero if interface is high current"]
    pub BIsHighCurrent: UCHAR,
    #[doc = " non-zero if interface is high current\n Hardware options"]
    pub AIsFifo: UCHAR,
    #[doc = " non-zero if interface is 245 FIFO"]
    pub AIsFifoTar: UCHAR,
    #[doc = " non-zero if interface is 245 FIFO CPU target"]
    pub AIsFastSer: UCHAR,
    #[doc = " non-zero if interface is Fast serial"]
    pub BIsFifo: UCHAR,
    #[doc = " non-zero if interface is 245 FIFO"]
    pub BIsFifoTar: UCHAR,
    #[doc = " non-zero if interface is 245 FIFO CPU target"]
    pub BIsFastSer: UCHAR,
    #[doc = " non-zero if interface is Fast serial\n Driver option"]
    pub ADriverType: UCHAR,
    #[doc = " non-zero if interface is to use VCP drivers"]
    pub BDriverType: UCHAR,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ft_eeprom_2232"][::std::mem::size_of::<ft_eeprom_2232>() - 28usize];
    ["Alignment of ft_eeprom_2232"][::std::mem::align_of::<ft_eeprom_2232>() - 4usize];
    ["Offset of field: ft_eeprom_2232::common"]
        [::std::mem::offset_of!(ft_eeprom_2232, common) - 0usize];
    ["Offset of field: ft_eeprom_2232::AIsHighCurrent"]
        [::std::mem::offset_of!(ft_eeprom_2232, AIsHighCurrent) - 16usize];
    ["Offset of field: ft_eeprom_2232::BIsHighCurrent"]
        [::std::mem::offset_of!(ft_eeprom_2232, BIsHighCurrent) - 17usize];
    ["Offset of field: ft_eeprom_2232::AIsFifo"]
        [::std::mem::offset_of!(ft_eeprom_2232, AIsFifo) - 18usize];
    ["Offset of field: ft_eeprom_2232::AIsFifoTar"]
        [::std::mem::offset_of!(ft_eeprom_2232, AIsFifoTar) - 19usize];
    ["Offset of field: ft_eeprom_2232::AIsFastSer"]
        [::std::mem::offset_of!(ft_eeprom_2232, AIsFastSer) - 20usize];
    ["Offset of field: ft_eeprom_2232::BIsFifo"]
        [::std::mem::offset_of!(ft_eeprom_2232, BIsFifo) - 21usize];
    ["Offset of field: ft_eeprom_2232::BIsFifoTar"]
        [::std::mem::offset_of!(ft_eeprom_2232, BIsFifoTar) - 22usize];
    ["Offset of field: ft_eeprom_2232::BIsFastSer"]
        [::std::mem::offset_of!(ft_eeprom_2232, BIsFastSer) - 23usize];
    ["Offset of field: ft_eeprom_2232::ADriverType"]
        [::std::mem::offset_of!(ft_eeprom_2232, ADriverType) - 24usize];
    ["Offset of field: ft_eeprom_2232::BDriverType"]
        [::std::mem::offset_of!(ft_eeprom_2232, BDriverType) - 25usize];
};
#[doc = "  @noop FT_EEPROM_2232\n @par Summary\n Structure to hold data for the FT2232C, FT2232D and FT2232L data in the FT_EEPROM_Program\n and FT_EEPROM_Read functions.\n This is appended to an FT_EEPROM_HEADER structure.\n @see FT_EEPROM_HEADER"]
pub type FT_EEPROM_2232 = ft_eeprom_2232;
#[doc = "  @noop FT_EEPROM_232R\n @par Summary\n Structure to hold data for the FT232R data in the FT_EEPROM_Program and FT_EEPROM_Read functions.\n This is appended to an FT_EEPROM_HEADER structure.\n @see FT_EEPROM_HEADER"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ft_eeprom_232r {
    #[doc = " Common header"]
    pub common: FT_EEPROM_HEADER,
    #[doc = " common elements for all device EEPROMs\n Drive options"]
    pub IsHighCurrent: UCHAR,
    #[doc = " non-zero if interface is high current\n Hardware options"]
    pub UseExtOsc: UCHAR,
    #[doc = " Use External Oscillator"]
    pub InvertTXD: UCHAR,
    #[doc = " non-zero if invert TXD"]
    pub InvertRXD: UCHAR,
    #[doc = " non-zero if invert RXD"]
    pub InvertRTS: UCHAR,
    #[doc = " non-zero if invert RTS"]
    pub InvertCTS: UCHAR,
    #[doc = " non-zero if invert CTS"]
    pub InvertDTR: UCHAR,
    #[doc = " non-zero if invert DTR"]
    pub InvertDSR: UCHAR,
    #[doc = " non-zero if invert DSR"]
    pub InvertDCD: UCHAR,
    #[doc = " non-zero if invert DCD"]
    pub InvertRI: UCHAR,
    #[doc = " non-zero if invert RI"]
    pub Cbus0: UCHAR,
    #[doc = " Cbus Mux control"]
    pub Cbus1: UCHAR,
    #[doc = " Cbus Mux control"]
    pub Cbus2: UCHAR,
    #[doc = " Cbus Mux control"]
    pub Cbus3: UCHAR,
    #[doc = " Cbus Mux control"]
    pub Cbus4: UCHAR,
    #[doc = " Cbus Mux control\n Driver option"]
    pub DriverType: UCHAR,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ft_eeprom_232r"][::std::mem::size_of::<ft_eeprom_232r>() - 32usize];
    ["Alignment of ft_eeprom_232r"][::std::mem::align_of::<ft_eeprom_232r>() - 4usize];
    ["Offset of field: ft_eeprom_232r::common"]
        [::std::mem::offset_of!(ft_eeprom_232r, common) - 0usize];
    ["Offset of field: ft_eeprom_232r::IsHighCurrent"]
        [::std::mem::offset_of!(ft_eeprom_232r, IsHighCurrent) - 16usize];
    ["Offset of field: ft_eeprom_232r::UseExtOsc"]
        [::std::mem::offset_of!(ft_eeprom_232r, UseExtOsc) - 17usize];
    ["Offset of field: ft_eeprom_232r::InvertTXD"]
        [::std::mem::offset_of!(ft_eeprom_232r, InvertTXD) - 18usize];
    ["Offset of field: ft_eeprom_232r::InvertRXD"]
        [::std::mem::offset_of!(ft_eeprom_232r, InvertRXD) - 19usize];
    ["Offset of field: ft_eeprom_232r::InvertRTS"]
        [::std::mem::offset_of!(ft_eeprom_232r, InvertRTS) - 20usize];
    ["Offset of field: ft_eeprom_232r::InvertCTS"]
        [::std::mem::offset_of!(ft_eeprom_232r, InvertCTS) - 21usize];
    ["Offset of field: ft_eeprom_232r::InvertDTR"]
        [::std::mem::offset_of!(ft_eeprom_232r, InvertDTR) - 22usize];
    ["Offset of field: ft_eeprom_232r::InvertDSR"]
        [::std::mem::offset_of!(ft_eeprom_232r, InvertDSR) - 23usize];
    ["Offset of field: ft_eeprom_232r::InvertDCD"]
        [::std::mem::offset_of!(ft_eeprom_232r, InvertDCD) - 24usize];
    ["Offset of field: ft_eeprom_232r::InvertRI"]
        [::std::mem::offset_of!(ft_eeprom_232r, InvertRI) - 25usize];
    ["Offset of field: ft_eeprom_232r::Cbus0"]
        [::std::mem::offset_of!(ft_eeprom_232r, Cbus0) - 26usize];
    ["Offset of field: ft_eeprom_232r::Cbus1"]
        [::std::mem::offset_of!(ft_eeprom_232r, Cbus1) - 27usize];
    ["Offset of field: ft_eeprom_232r::Cbus2"]
        [::std::mem::offset_of!(ft_eeprom_232r, Cbus2) - 28usize];
    ["Offset of field: ft_eeprom_232r::Cbus3"]
        [::std::mem::offset_of!(ft_eeprom_232r, Cbus3) - 29usize];
    ["Offset of field: ft_eeprom_232r::Cbus4"]
        [::std::mem::offset_of!(ft_eeprom_232r, Cbus4) - 30usize];
    ["Offset of field: ft_eeprom_232r::DriverType"]
        [::std::mem::offset_of!(ft_eeprom_232r, DriverType) - 31usize];
};
#[doc = "  @noop FT_EEPROM_232R\n @par Summary\n Structure to hold data for the FT232R data in the FT_EEPROM_Program and FT_EEPROM_Read functions.\n This is appended to an FT_EEPROM_HEADER structure.\n @see FT_EEPROM_HEADER"]
pub type FT_EEPROM_232R = ft_eeprom_232r;
#[doc = "  @noop FT_EEPROM_2232H\n @par Summary\n Structure to hold data for the FT2232H data in the FT_EEPROM_Program and FT_EEPROM_Read functions.\n This is appended to an FT_EEPROM_HEADER structure.\n @see FT_EEPROM_HEADER"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ft_eeprom_2232h {
    #[doc = " Common header"]
    pub common: FT_EEPROM_HEADER,
    #[doc = " common elements for all device EEPROMs\n Drive options"]
    pub ALSlowSlew: UCHAR,
    #[doc = " non-zero if AL pins have slow slew"]
    pub ALSchmittInput: UCHAR,
    #[doc = " non-zero if AL pins are Schmitt input"]
    pub ALDriveCurrent: UCHAR,
    #[doc = " valid values are 4mA, 8mA, 12mA, 16mA"]
    pub AHSlowSlew: UCHAR,
    #[doc = " non-zero if AH pins have slow slew"]
    pub AHSchmittInput: UCHAR,
    #[doc = " non-zero if AH pins are Schmitt input"]
    pub AHDriveCurrent: UCHAR,
    #[doc = " valid values are 4mA, 8mA, 12mA, 16mA"]
    pub BLSlowSlew: UCHAR,
    #[doc = " non-zero if BL pins have slow slew"]
    pub BLSchmittInput: UCHAR,
    #[doc = " non-zero if BL pins are Schmitt input"]
    pub BLDriveCurrent: UCHAR,
    #[doc = " valid values are 4mA, 8mA, 12mA, 16mA"]
    pub BHSlowSlew: UCHAR,
    #[doc = " non-zero if BH pins have slow slew"]
    pub BHSchmittInput: UCHAR,
    #[doc = " non-zero if BH pins are Schmitt input"]
    pub BHDriveCurrent: UCHAR,
    #[doc = " valid values are 4mA, 8mA, 12mA, 16mA\n Hardware options"]
    pub AIsFifo: UCHAR,
    #[doc = " non-zero if interface is 245 FIFO"]
    pub AIsFifoTar: UCHAR,
    #[doc = " non-zero if interface is 245 FIFO CPU target"]
    pub AIsFastSer: UCHAR,
    #[doc = " non-zero if interface is Fast serial"]
    pub BIsFifo: UCHAR,
    #[doc = " non-zero if interface is 245 FIFO"]
    pub BIsFifoTar: UCHAR,
    #[doc = " non-zero if interface is 245 FIFO CPU target"]
    pub BIsFastSer: UCHAR,
    #[doc = " non-zero if interface is Fast serial"]
    pub PowerSaveEnable: UCHAR,
    #[doc = " non-zero if using BCBUS7 to save power for self-powered designs\n Driver option"]
    pub ADriverType: UCHAR,
    #[doc = " non-zero if interface is to use VCP drivers"]
    pub BDriverType: UCHAR,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ft_eeprom_2232h"][::std::mem::size_of::<ft_eeprom_2232h>() - 40usize];
    ["Alignment of ft_eeprom_2232h"][::std::mem::align_of::<ft_eeprom_2232h>() - 4usize];
    ["Offset of field: ft_eeprom_2232h::common"]
        [::std::mem::offset_of!(ft_eeprom_2232h, common) - 0usize];
    ["Offset of field: ft_eeprom_2232h::ALSlowSlew"]
        [::std::mem::offset_of!(ft_eeprom_2232h, ALSlowSlew) - 16usize];
    ["Offset of field: ft_eeprom_2232h::ALSchmittInput"]
        [::std::mem::offset_of!(ft_eeprom_2232h, ALSchmittInput) - 17usize];
    ["Offset of field: ft_eeprom_2232h::ALDriveCurrent"]
        [::std::mem::offset_of!(ft_eeprom_2232h, ALDriveCurrent) - 18usize];
    ["Offset of field: ft_eeprom_2232h::AHSlowSlew"]
        [::std::mem::offset_of!(ft_eeprom_2232h, AHSlowSlew) - 19usize];
    ["Offset of field: ft_eeprom_2232h::AHSchmittInput"]
        [::std::mem::offset_of!(ft_eeprom_2232h, AHSchmittInput) - 20usize];
    ["Offset of field: ft_eeprom_2232h::AHDriveCurrent"]
        [::std::mem::offset_of!(ft_eeprom_2232h, AHDriveCurrent) - 21usize];
    ["Offset of field: ft_eeprom_2232h::BLSlowSlew"]
        [::std::mem::offset_of!(ft_eeprom_2232h, BLSlowSlew) - 22usize];
    ["Offset of field: ft_eeprom_2232h::BLSchmittInput"]
        [::std::mem::offset_of!(ft_eeprom_2232h, BLSchmittInput) - 23usize];
    ["Offset of field: ft_eeprom_2232h::BLDriveCurrent"]
        [::std::mem::offset_of!(ft_eeprom_2232h, BLDriveCurrent) - 24usize];
    ["Offset of field: ft_eeprom_2232h::BHSlowSlew"]
        [::std::mem::offset_of!(ft_eeprom_2232h, BHSlowSlew) - 25usize];
    ["Offset of field: ft_eeprom_2232h::BHSchmittInput"]
        [::std::mem::offset_of!(ft_eeprom_2232h, BHSchmittInput) - 26usize];
    ["Offset of field: ft_eeprom_2232h::BHDriveCurrent"]
        [::std::mem::offset_of!(ft_eeprom_2232h, BHDriveCurrent) - 27usize];
    ["Offset of field: ft_eeprom_2232h::AIsFifo"]
        [::std::mem::offset_of!(ft_eeprom_2232h, AIsFifo) - 28usize];
    ["Offset of field: ft_eeprom_2232h::AIsFifoTar"]
        [::std::mem::offset_of!(ft_eeprom_2232h, AIsFifoTar) - 29usize];
    ["Offset of field: ft_eeprom_2232h::AIsFastSer"]
        [::std::mem::offset_of!(ft_eeprom_2232h, AIsFastSer) - 30usize];
    ["Offset of field: ft_eeprom_2232h::BIsFifo"]
        [::std::mem::offset_of!(ft_eeprom_2232h, BIsFifo) - 31usize];
    ["Offset of field: ft_eeprom_2232h::BIsFifoTar"]
        [::std::mem::offset_of!(ft_eeprom_2232h, BIsFifoTar) - 32usize];
    ["Offset of field: ft_eeprom_2232h::BIsFastSer"]
        [::std::mem::offset_of!(ft_eeprom_2232h, BIsFastSer) - 33usize];
    ["Offset of field: ft_eeprom_2232h::PowerSaveEnable"]
        [::std::mem::offset_of!(ft_eeprom_2232h, PowerSaveEnable) - 34usize];
    ["Offset of field: ft_eeprom_2232h::ADriverType"]
        [::std::mem::offset_of!(ft_eeprom_2232h, ADriverType) - 35usize];
    ["Offset of field: ft_eeprom_2232h::BDriverType"]
        [::std::mem::offset_of!(ft_eeprom_2232h, BDriverType) - 36usize];
};
#[doc = "  @noop FT_EEPROM_2232H\n @par Summary\n Structure to hold data for the FT2232H data in the FT_EEPROM_Program and FT_EEPROM_Read functions.\n This is appended to an FT_EEPROM_HEADER structure.\n @see FT_EEPROM_HEADER"]
pub type FT_EEPROM_2232H = ft_eeprom_2232h;
#[doc = "  @noop FT_EEPROM_4232H\n @par Summary\n Structure to hold data for the FT4232H data in the FT_EEPROM_Program and FT_EEPROM_Read functions.\n This is appended to an FT_EEPROM_HEADER structure.\n @see FT_EEPROM_HEADER"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ft_eeprom_4232h {
    #[doc = " Common header"]
    pub common: FT_EEPROM_HEADER,
    #[doc = " common elements for all device EEPROMs\n Drive options"]
    pub ASlowSlew: UCHAR,
    #[doc = " non-zero if A pins have slow slew"]
    pub ASchmittInput: UCHAR,
    #[doc = " non-zero if A pins are Schmitt input"]
    pub ADriveCurrent: UCHAR,
    #[doc = " valid values are 4mA, 8mA, 12mA, 16mA"]
    pub BSlowSlew: UCHAR,
    #[doc = " non-zero if B pins have slow slew"]
    pub BSchmittInput: UCHAR,
    #[doc = " non-zero if B pins are Schmitt input"]
    pub BDriveCurrent: UCHAR,
    #[doc = " valid values are 4mA, 8mA, 12mA, 16mA"]
    pub CSlowSlew: UCHAR,
    #[doc = " non-zero if C pins have slow slew"]
    pub CSchmittInput: UCHAR,
    #[doc = " non-zero if C pins are Schmitt input"]
    pub CDriveCurrent: UCHAR,
    #[doc = " valid values are 4mA, 8mA, 12mA, 16mA"]
    pub DSlowSlew: UCHAR,
    #[doc = " non-zero if D pins have slow slew"]
    pub DSchmittInput: UCHAR,
    #[doc = " non-zero if D pins are Schmitt input"]
    pub DDriveCurrent: UCHAR,
    #[doc = " valid values are 4mA, 8mA, 12mA, 16mA\n Hardware options"]
    pub ARIIsTXDEN: UCHAR,
    #[doc = " non-zero if port A uses RI as RS485 TXDEN"]
    pub BRIIsTXDEN: UCHAR,
    #[doc = " non-zero if port B uses RI as RS485 TXDEN"]
    pub CRIIsTXDEN: UCHAR,
    #[doc = " non-zero if port C uses RI as RS485 TXDEN"]
    pub DRIIsTXDEN: UCHAR,
    #[doc = " non-zero if port D uses RI as RS485 TXDEN\n Driver option"]
    pub ADriverType: UCHAR,
    #[doc = " non-zero if interface is to use VCP drivers"]
    pub BDriverType: UCHAR,
    #[doc = " non-zero if interface is to use VCP drivers"]
    pub CDriverType: UCHAR,
    #[doc = " non-zero if interface is to use VCP drivers"]
    pub DDriverType: UCHAR,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ft_eeprom_4232h"][::std::mem::size_of::<ft_eeprom_4232h>() - 36usize];
    ["Alignment of ft_eeprom_4232h"][::std::mem::align_of::<ft_eeprom_4232h>() - 4usize];
    ["Offset of field: ft_eeprom_4232h::common"]
        [::std::mem::offset_of!(ft_eeprom_4232h, common) - 0usize];
    ["Offset of field: ft_eeprom_4232h::ASlowSlew"]
        [::std::mem::offset_of!(ft_eeprom_4232h, ASlowSlew) - 16usize];
    ["Offset of field: ft_eeprom_4232h::ASchmittInput"]
        [::std::mem::offset_of!(ft_eeprom_4232h, ASchmittInput) - 17usize];
    ["Offset of field: ft_eeprom_4232h::ADriveCurrent"]
        [::std::mem::offset_of!(ft_eeprom_4232h, ADriveCurrent) - 18usize];
    ["Offset of field: ft_eeprom_4232h::BSlowSlew"]
        [::std::mem::offset_of!(ft_eeprom_4232h, BSlowSlew) - 19usize];
    ["Offset of field: ft_eeprom_4232h::BSchmittInput"]
        [::std::mem::offset_of!(ft_eeprom_4232h, BSchmittInput) - 20usize];
    ["Offset of field: ft_eeprom_4232h::BDriveCurrent"]
        [::std::mem::offset_of!(ft_eeprom_4232h, BDriveCurrent) - 21usize];
    ["Offset of field: ft_eeprom_4232h::CSlowSlew"]
        [::std::mem::offset_of!(ft_eeprom_4232h, CSlowSlew) - 22usize];
    ["Offset of field: ft_eeprom_4232h::CSchmittInput"]
        [::std::mem::offset_of!(ft_eeprom_4232h, CSchmittInput) - 23usize];
    ["Offset of field: ft_eeprom_4232h::CDriveCurrent"]
        [::std::mem::offset_of!(ft_eeprom_4232h, CDriveCurrent) - 24usize];
    ["Offset of field: ft_eeprom_4232h::DSlowSlew"]
        [::std::mem::offset_of!(ft_eeprom_4232h, DSlowSlew) - 25usize];
    ["Offset of field: ft_eeprom_4232h::DSchmittInput"]
        [::std::mem::offset_of!(ft_eeprom_4232h, DSchmittInput) - 26usize];
    ["Offset of field: ft_eeprom_4232h::DDriveCurrent"]
        [::std::mem::offset_of!(ft_eeprom_4232h, DDriveCurrent) - 27usize];
    ["Offset of field: ft_eeprom_4232h::ARIIsTXDEN"]
        [::std::mem::offset_of!(ft_eeprom_4232h, ARIIsTXDEN) - 28usize];
    ["Offset of field: ft_eeprom_4232h::BRIIsTXDEN"]
        [::std::mem::offset_of!(ft_eeprom_4232h, BRIIsTXDEN) - 29usize];
    ["Offset of field: ft_eeprom_4232h::CRIIsTXDEN"]
        [::std::mem::offset_of!(ft_eeprom_4232h, CRIIsTXDEN) - 30usize];
    ["Offset of field: ft_eeprom_4232h::DRIIsTXDEN"]
        [::std::mem::offset_of!(ft_eeprom_4232h, DRIIsTXDEN) - 31usize];
    ["Offset of field: ft_eeprom_4232h::ADriverType"]
        [::std::mem::offset_of!(ft_eeprom_4232h, ADriverType) - 32usize];
    ["Offset of field: ft_eeprom_4232h::BDriverType"]
        [::std::mem::offset_of!(ft_eeprom_4232h, BDriverType) - 33usize];
    ["Offset of field: ft_eeprom_4232h::CDriverType"]
        [::std::mem::offset_of!(ft_eeprom_4232h, CDriverType) - 34usize];
    ["Offset of field: ft_eeprom_4232h::DDriverType"]
        [::std::mem::offset_of!(ft_eeprom_4232h, DDriverType) - 35usize];
};
#[doc = "  @noop FT_EEPROM_4232H\n @par Summary\n Structure to hold data for the FT4232H data in the FT_EEPROM_Program and FT_EEPROM_Read functions.\n This is appended to an FT_EEPROM_HEADER structure.\n @see FT_EEPROM_HEADER"]
pub type FT_EEPROM_4232H = ft_eeprom_4232h;
#[doc = "  @noop FT_EEPROM_232H\n @par Summary\n Structure to hold data for the FT232H data in the FT_EEPROM_Program and FT_EEPROM_Read functions.\n This is appended to an FT_EEPROM_HEADER structure.\n @see FT_EEPROM_HEADER"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ft_eeprom_232h {
    #[doc = " Common header"]
    pub common: FT_EEPROM_HEADER,
    #[doc = " common elements for all device EEPROMs\n Drive options"]
    pub ACSlowSlew: UCHAR,
    #[doc = " non-zero if AC bus pins have slow slew"]
    pub ACSchmittInput: UCHAR,
    #[doc = " non-zero if AC bus pins are Schmitt input"]
    pub ACDriveCurrent: UCHAR,
    #[doc = " valid values are 4mA, 8mA, 12mA, 16mA"]
    pub ADSlowSlew: UCHAR,
    #[doc = " non-zero if AD bus pins have slow slew"]
    pub ADSchmittInput: UCHAR,
    #[doc = " non-zero if AD bus pins are Schmitt input"]
    pub ADDriveCurrent: UCHAR,
    #[doc = " valid values are 4mA, 8mA, 12mA, 16mA\n CBUS options"]
    pub Cbus0: UCHAR,
    #[doc = " Cbus Mux control"]
    pub Cbus1: UCHAR,
    #[doc = " Cbus Mux control"]
    pub Cbus2: UCHAR,
    #[doc = " Cbus Mux control"]
    pub Cbus3: UCHAR,
    #[doc = " Cbus Mux control"]
    pub Cbus4: UCHAR,
    #[doc = " Cbus Mux control"]
    pub Cbus5: UCHAR,
    #[doc = " Cbus Mux control"]
    pub Cbus6: UCHAR,
    #[doc = " Cbus Mux control"]
    pub Cbus7: UCHAR,
    #[doc = " Cbus Mux control"]
    pub Cbus8: UCHAR,
    #[doc = " Cbus Mux control"]
    pub Cbus9: UCHAR,
    #[doc = " Cbus Mux control\n FT1248 options"]
    pub FT1248Cpol: UCHAR,
    #[doc = " FT1248 clock polarity - clock idle high (1) or clock idle low (0)"]
    pub FT1248Lsb: UCHAR,
    #[doc = " FT1248 data is LSB (1) or MSB (0)"]
    pub FT1248FlowControl: UCHAR,
    #[doc = " FT1248 flow control enable\n Hardware options"]
    pub IsFifo: UCHAR,
    #[doc = " non-zero if interface is 245 FIFO"]
    pub IsFifoTar: UCHAR,
    #[doc = " non-zero if interface is 245 FIFO CPU target"]
    pub IsFastSer: UCHAR,
    #[doc = " non-zero if interface is Fast serial"]
    pub IsFT1248: UCHAR,
    #[doc = " non-zero if interface is FT1248"]
    pub PowerSaveEnable: UCHAR,
    #[doc = "\n Driver option"]
    pub DriverType: UCHAR,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ft_eeprom_232h"][::std::mem::size_of::<ft_eeprom_232h>() - 44usize];
    ["Alignment of ft_eeprom_232h"][::std::mem::align_of::<ft_eeprom_232h>() - 4usize];
    ["Offset of field: ft_eeprom_232h::common"]
        [::std::mem::offset_of!(ft_eeprom_232h, common) - 0usize];
    ["Offset of field: ft_eeprom_232h::ACSlowSlew"]
        [::std::mem::offset_of!(ft_eeprom_232h, ACSlowSlew) - 16usize];
    ["Offset of field: ft_eeprom_232h::ACSchmittInput"]
        [::std::mem::offset_of!(ft_eeprom_232h, ACSchmittInput) - 17usize];
    ["Offset of field: ft_eeprom_232h::ACDriveCurrent"]
        [::std::mem::offset_of!(ft_eeprom_232h, ACDriveCurrent) - 18usize];
    ["Offset of field: ft_eeprom_232h::ADSlowSlew"]
        [::std::mem::offset_of!(ft_eeprom_232h, ADSlowSlew) - 19usize];
    ["Offset of field: ft_eeprom_232h::ADSchmittInput"]
        [::std::mem::offset_of!(ft_eeprom_232h, ADSchmittInput) - 20usize];
    ["Offset of field: ft_eeprom_232h::ADDriveCurrent"]
        [::std::mem::offset_of!(ft_eeprom_232h, ADDriveCurrent) - 21usize];
    ["Offset of field: ft_eeprom_232h::Cbus0"]
        [::std::mem::offset_of!(ft_eeprom_232h, Cbus0) - 22usize];
    ["Offset of field: ft_eeprom_232h::Cbus1"]
        [::std::mem::offset_of!(ft_eeprom_232h, Cbus1) - 23usize];
    ["Offset of field: ft_eeprom_232h::Cbus2"]
        [::std::mem::offset_of!(ft_eeprom_232h, Cbus2) - 24usize];
    ["Offset of field: ft_eeprom_232h::Cbus3"]
        [::std::mem::offset_of!(ft_eeprom_232h, Cbus3) - 25usize];
    ["Offset of field: ft_eeprom_232h::Cbus4"]
        [::std::mem::offset_of!(ft_eeprom_232h, Cbus4) - 26usize];
    ["Offset of field: ft_eeprom_232h::Cbus5"]
        [::std::mem::offset_of!(ft_eeprom_232h, Cbus5) - 27usize];
    ["Offset of field: ft_eeprom_232h::Cbus6"]
        [::std::mem::offset_of!(ft_eeprom_232h, Cbus6) - 28usize];
    ["Offset of field: ft_eeprom_232h::Cbus7"]
        [::std::mem::offset_of!(ft_eeprom_232h, Cbus7) - 29usize];
    ["Offset of field: ft_eeprom_232h::Cbus8"]
        [::std::mem::offset_of!(ft_eeprom_232h, Cbus8) - 30usize];
    ["Offset of field: ft_eeprom_232h::Cbus9"]
        [::std::mem::offset_of!(ft_eeprom_232h, Cbus9) - 31usize];
    ["Offset of field: ft_eeprom_232h::FT1248Cpol"]
        [::std::mem::offset_of!(ft_eeprom_232h, FT1248Cpol) - 32usize];
    ["Offset of field: ft_eeprom_232h::FT1248Lsb"]
        [::std::mem::offset_of!(ft_eeprom_232h, FT1248Lsb) - 33usize];
    ["Offset of field: ft_eeprom_232h::FT1248FlowControl"]
        [::std::mem::offset_of!(ft_eeprom_232h, FT1248FlowControl) - 34usize];
    ["Offset of field: ft_eeprom_232h::IsFifo"]
        [::std::mem::offset_of!(ft_eeprom_232h, IsFifo) - 35usize];
    ["Offset of field: ft_eeprom_232h::IsFifoTar"]
        [::std::mem::offset_of!(ft_eeprom_232h, IsFifoTar) - 36usize];
    ["Offset of field: ft_eeprom_232h::IsFastSer"]
        [::std::mem::offset_of!(ft_eeprom_232h, IsFastSer) - 37usize];
    ["Offset of field: ft_eeprom_232h::IsFT1248"]
        [::std::mem::offset_of!(ft_eeprom_232h, IsFT1248) - 38usize];
    ["Offset of field: ft_eeprom_232h::PowerSaveEnable"]
        [::std::mem::offset_of!(ft_eeprom_232h, PowerSaveEnable) - 39usize];
    ["Offset of field: ft_eeprom_232h::DriverType"]
        [::std::mem::offset_of!(ft_eeprom_232h, DriverType) - 40usize];
};
#[doc = "  @noop FT_EEPROM_232H\n @par Summary\n Structure to hold data for the FT232H data in the FT_EEPROM_Program and FT_EEPROM_Read functions.\n This is appended to an FT_EEPROM_HEADER structure.\n @see FT_EEPROM_HEADER"]
pub type FT_EEPROM_232H = ft_eeprom_232h;
#[doc = "  @noop FT_EEPROM_X_SERIES\n @par Summary\n Structure to hold data for the FT-X series data in the FT_EEPROM_Program and FT_EEPROM_Read functions.\n This is appended to an FT_EEPROM_HEADER structure.\n @see FT_EEPROM_HEADER"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ft_eeprom_x_series {
    #[doc = " Common header"]
    pub common: FT_EEPROM_HEADER,
    #[doc = " common elements for all device EEPROMs\n Drive options"]
    pub ACSlowSlew: UCHAR,
    #[doc = " non-zero if AC bus pins have slow slew"]
    pub ACSchmittInput: UCHAR,
    #[doc = " non-zero if AC bus pins are Schmitt input"]
    pub ACDriveCurrent: UCHAR,
    #[doc = " valid values are 4mA, 8mA, 12mA, 16mA"]
    pub ADSlowSlew: UCHAR,
    #[doc = " non-zero if AD bus pins have slow slew"]
    pub ADSchmittInput: UCHAR,
    #[doc = " non-zero if AD bus pins are Schmitt input"]
    pub ADDriveCurrent: UCHAR,
    #[doc = " valid values are 4mA, 8mA, 12mA, 16mA\n CBUS options"]
    pub Cbus0: UCHAR,
    #[doc = " Cbus Mux control"]
    pub Cbus1: UCHAR,
    #[doc = " Cbus Mux control"]
    pub Cbus2: UCHAR,
    #[doc = " Cbus Mux control"]
    pub Cbus3: UCHAR,
    #[doc = " Cbus Mux control"]
    pub Cbus4: UCHAR,
    #[doc = " Cbus Mux control"]
    pub Cbus5: UCHAR,
    #[doc = " Cbus Mux control"]
    pub Cbus6: UCHAR,
    #[doc = " Cbus Mux control\n UART signal options"]
    pub InvertTXD: UCHAR,
    #[doc = " non-zero if invert TXD"]
    pub InvertRXD: UCHAR,
    #[doc = " non-zero if invert RXD"]
    pub InvertRTS: UCHAR,
    #[doc = " non-zero if invert RTS"]
    pub InvertCTS: UCHAR,
    #[doc = " non-zero if invert CTS"]
    pub InvertDTR: UCHAR,
    #[doc = " non-zero if invert DTR"]
    pub InvertDSR: UCHAR,
    #[doc = " non-zero if invert DSR"]
    pub InvertDCD: UCHAR,
    #[doc = " non-zero if invert DCD"]
    pub InvertRI: UCHAR,
    #[doc = " non-zero if invert RI\n Battery Charge Detect options"]
    pub BCDEnable: UCHAR,
    #[doc = " Enable Battery Charger Detection"]
    pub BCDForceCbusPWREN: UCHAR,
    #[doc = " asserts the power enable signal on CBUS when charging port detected"]
    pub BCDDisableSleep: UCHAR,
    #[doc = " forces the device never to go into sleep mode\n I2C options"]
    pub I2CSlaveAddress: WORD,
    #[doc = " I2C slave device address"]
    pub I2CDeviceId: DWORD,
    #[doc = " I2C device ID"]
    pub I2CDisableSchmitt: UCHAR,
    #[doc = " Disable I2C Schmitt trigger\n FT1248 options"]
    pub FT1248Cpol: UCHAR,
    #[doc = " FT1248 clock polarity - clock idle high (1) or clock idle low (0)"]
    pub FT1248Lsb: UCHAR,
    #[doc = " FT1248 data is LSB (1) or MSB (0)"]
    pub FT1248FlowControl: UCHAR,
    #[doc = " FT1248 flow control enable\n Hardware options"]
    pub RS485EchoSuppress: UCHAR,
    pub PowerSaveEnable: UCHAR,
    #[doc = "\n Driver option"]
    pub DriverType: UCHAR,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ft_eeprom_x_series"][::std::mem::size_of::<ft_eeprom_x_series>() - 56usize];
    ["Alignment of ft_eeprom_x_series"][::std::mem::align_of::<ft_eeprom_x_series>() - 4usize];
    ["Offset of field: ft_eeprom_x_series::common"]
        [::std::mem::offset_of!(ft_eeprom_x_series, common) - 0usize];
    ["Offset of field: ft_eeprom_x_series::ACSlowSlew"]
        [::std::mem::offset_of!(ft_eeprom_x_series, ACSlowSlew) - 16usize];
    ["Offset of field: ft_eeprom_x_series::ACSchmittInput"]
        [::std::mem::offset_of!(ft_eeprom_x_series, ACSchmittInput) - 17usize];
    ["Offset of field: ft_eeprom_x_series::ACDriveCurrent"]
        [::std::mem::offset_of!(ft_eeprom_x_series, ACDriveCurrent) - 18usize];
    ["Offset of field: ft_eeprom_x_series::ADSlowSlew"]
        [::std::mem::offset_of!(ft_eeprom_x_series, ADSlowSlew) - 19usize];
    ["Offset of field: ft_eeprom_x_series::ADSchmittInput"]
        [::std::mem::offset_of!(ft_eeprom_x_series, ADSchmittInput) - 20usize];
    ["Offset of field: ft_eeprom_x_series::ADDriveCurrent"]
        [::std::mem::offset_of!(ft_eeprom_x_series, ADDriveCurrent) - 21usize];
    ["Offset of field: ft_eeprom_x_series::Cbus0"]
        [::std::mem::offset_of!(ft_eeprom_x_series, Cbus0) - 22usize];
    ["Offset of field: ft_eeprom_x_series::Cbus1"]
        [::std::mem::offset_of!(ft_eeprom_x_series, Cbus1) - 23usize];
    ["Offset of field: ft_eeprom_x_series::Cbus2"]
        [::std::mem::offset_of!(ft_eeprom_x_series, Cbus2) - 24usize];
    ["Offset of field: ft_eeprom_x_series::Cbus3"]
        [::std::mem::offset_of!(ft_eeprom_x_series, Cbus3) - 25usize];
    ["Offset of field: ft_eeprom_x_series::Cbus4"]
        [::std::mem::offset_of!(ft_eeprom_x_series, Cbus4) - 26usize];
    ["Offset of field: ft_eeprom_x_series::Cbus5"]
        [::std::mem::offset_of!(ft_eeprom_x_series, Cbus5) - 27usize];
    ["Offset of field: ft_eeprom_x_series::Cbus6"]
        [::std::mem::offset_of!(ft_eeprom_x_series, Cbus6) - 28usize];
    ["Offset of field: ft_eeprom_x_series::InvertTXD"]
        [::std::mem::offset_of!(ft_eeprom_x_series, InvertTXD) - 29usize];
    ["Offset of field: ft_eeprom_x_series::InvertRXD"]
        [::std::mem::offset_of!(ft_eeprom_x_series, InvertRXD) - 30usize];
    ["Offset of field: ft_eeprom_x_series::InvertRTS"]
        [::std::mem::offset_of!(ft_eeprom_x_series, InvertRTS) - 31usize];
    ["Offset of field: ft_eeprom_x_series::InvertCTS"]
        [::std::mem::offset_of!(ft_eeprom_x_series, InvertCTS) - 32usize];
    ["Offset of field: ft_eeprom_x_series::InvertDTR"]
        [::std::mem::offset_of!(ft_eeprom_x_series, InvertDTR) - 33usize];
    ["Offset of field: ft_eeprom_x_series::InvertDSR"]
        [::std::mem::offset_of!(ft_eeprom_x_series, InvertDSR) - 34usize];
    ["Offset of field: ft_eeprom_x_series::InvertDCD"]
        [::std::mem::offset_of!(ft_eeprom_x_series, InvertDCD) - 35usize];
    ["Offset of field: ft_eeprom_x_series::InvertRI"]
        [::std::mem::offset_of!(ft_eeprom_x_series, InvertRI) - 36usize];
    ["Offset of field: ft_eeprom_x_series::BCDEnable"]
        [::std::mem::offset_of!(ft_eeprom_x_series, BCDEnable) - 37usize];
    ["Offset of field: ft_eeprom_x_series::BCDForceCbusPWREN"]
        [::std::mem::offset_of!(ft_eeprom_x_series, BCDForceCbusPWREN) - 38usize];
    ["Offset of field: ft_eeprom_x_series::BCDDisableSleep"]
        [::std::mem::offset_of!(ft_eeprom_x_series, BCDDisableSleep) - 39usize];
    ["Offset of field: ft_eeprom_x_series::I2CSlaveAddress"]
        [::std::mem::offset_of!(ft_eeprom_x_series, I2CSlaveAddress) - 40usize];
    ["Offset of field: ft_eeprom_x_series::I2CDeviceId"]
        [::std::mem::offset_of!(ft_eeprom_x_series, I2CDeviceId) - 44usize];
    ["Offset of field: ft_eeprom_x_series::I2CDisableSchmitt"]
        [::std::mem::offset_of!(ft_eeprom_x_series, I2CDisableSchmitt) - 48usize];
    ["Offset of field: ft_eeprom_x_series::FT1248Cpol"]
        [::std::mem::offset_of!(ft_eeprom_x_series, FT1248Cpol) - 49usize];
    ["Offset of field: ft_eeprom_x_series::FT1248Lsb"]
        [::std::mem::offset_of!(ft_eeprom_x_series, FT1248Lsb) - 50usize];
    ["Offset of field: ft_eeprom_x_series::FT1248FlowControl"]
        [::std::mem::offset_of!(ft_eeprom_x_series, FT1248FlowControl) - 51usize];
    ["Offset of field: ft_eeprom_x_series::RS485EchoSuppress"]
        [::std::mem::offset_of!(ft_eeprom_x_series, RS485EchoSuppress) - 52usize];
    ["Offset of field: ft_eeprom_x_series::PowerSaveEnable"]
        [::std::mem::offset_of!(ft_eeprom_x_series, PowerSaveEnable) - 53usize];
    ["Offset of field: ft_eeprom_x_series::DriverType"]
        [::std::mem::offset_of!(ft_eeprom_x_series, DriverType) - 54usize];
};
#[doc = "  @noop FT_EEPROM_X_SERIES\n @par Summary\n Structure to hold data for the FT-X series data in the FT_EEPROM_Program and FT_EEPROM_Read functions.\n This is appended to an FT_EEPROM_HEADER structure.\n @see FT_EEPROM_HEADER"]
pub type FT_EEPROM_X_SERIES = ft_eeprom_x_series;
#[doc = "  @noop FT_EEPROM_4222H\n @par Summary\n Structure to hold data for the FT4222H data in the FT_EEPROM_Program and FT_EEPROM_Read functions.\n This is appended to an FT_EEPROM_HEADER structure.\n @see FT_EEPROM_HEADER"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ft_eeprom_4222h {
    #[doc = " Common header"]
    pub common: FT_EEPROM_HEADER,
    #[doc = " common elements for all device EEPROMs"]
    pub Revision: CHAR,
    #[doc = " 'A', 'B', 'C', or 'D'."]
    pub I2C_Slave_Address: UCHAR,
    #[doc = " Suspend"]
    pub SPISuspend: UCHAR,
    #[doc = " 0 for \"Disable SPI, tristate pins\", 2 for \"Keep SPI pin status\", 3 for \"Enable SPI pin control\""]
    pub SuspendOutPol: UCHAR,
    #[doc = " 0 for negative, 1 for positive (not implemented on Rev A)"]
    pub EnableSuspendOut: UCHAR,
    #[doc = " non-zero to enable (not implemented on Rev A)\n QSPI"]
    pub Clock_SlowSlew: UCHAR,
    #[doc = " non-zero if clock pin has slow slew"]
    pub Clock_Drive: UCHAR,
    #[doc = " valid values are 4mA, 8mA, 12mA, 16mA"]
    pub IO0_SlowSlew: UCHAR,
    #[doc = " non-zero if IO0 pin has slow slew"]
    pub IO1_SlowSlew: UCHAR,
    #[doc = " non-zero if IO1 pin has slow slew"]
    pub IO2_SlowSlew: UCHAR,
    #[doc = " non-zero if IO2 pin has slow slew"]
    pub IO3_SlowSlew: UCHAR,
    #[doc = " non-zero if IO3 pin has slow slew"]
    pub IO_Drive: UCHAR,
    #[doc = " valid values are 4mA, 8mA, 12mA, 16mA"]
    pub SlaveSelect_PullUp: UCHAR,
    #[doc = " non-zero to enable pull up"]
    pub SlaveSelect_PullDown: UCHAR,
    #[doc = " non-zero to enable pull down"]
    pub SlaveSelect_Drive: UCHAR,
    #[doc = " valid values are 4mA, 8mA, 12mA, 16mA"]
    pub SlaveSelect_SlowSlew: UCHAR,
    #[doc = " non-zero if slave select pin has slow slew"]
    pub MISO_Suspend: UCHAR,
    #[doc = " 2 for push-low, 3 for push high, 0 and 1 reserved"]
    pub SIMO_Suspend: UCHAR,
    #[doc = " 2 for push-low, 3 for push high, 0 and 1 reserved"]
    pub IO2_IO3_Suspend: UCHAR,
    #[doc = " 2 for push-low, 3 for push high, 0 and 1 reserved"]
    pub SlaveSelect_Suspend: UCHAR,
    #[doc = " 0 for no-change (not implemented on Rev A), 2 for push-low, 3 for push high, 1 reserved\n GPIO"]
    pub GPIO0_Drive: UCHAR,
    #[doc = " valid values are 4mA, 8mA, 12mA, 16mA"]
    pub GPIO1_Drive: UCHAR,
    #[doc = " valid values are 4mA, 8mA, 12mA, 16mA"]
    pub GPIO2_Drive: UCHAR,
    #[doc = " valid values are 4mA, 8mA, 12mA, 16mA"]
    pub GPIO3_Drive: UCHAR,
    #[doc = " valid values are 4mA, 8mA, 12mA, 16mA"]
    pub GPIO0_SlowSlew: UCHAR,
    #[doc = " non-zero if IO0 pin has slow slew"]
    pub GPIO1_SlowSlew: UCHAR,
    #[doc = " non-zero if IO0 pin has slow slew"]
    pub GPIO2_SlowSlew: UCHAR,
    #[doc = " non-zero if IO0 pin has slow slew"]
    pub GPIO3_SlowSlew: UCHAR,
    #[doc = " non-zero if IO0 pin has slow slew"]
    pub GPIO0_PullDown: UCHAR,
    #[doc = " non-zero to enable pull down"]
    pub GPIO1_PullDown: UCHAR,
    #[doc = " non-zero to enable pull down"]
    pub GPIO2_PullDown: UCHAR,
    #[doc = " non-zero to enable pull down"]
    pub GPIO3_PullDown: UCHAR,
    #[doc = " non-zero to enable pull down"]
    pub GPIO0_PullUp: UCHAR,
    #[doc = " non-zero to enable pull up"]
    pub GPIO1_PullUp: UCHAR,
    #[doc = " non-zero to enable pull up"]
    pub GPIO2_PullUp: UCHAR,
    #[doc = " non-zero to enable pull up"]
    pub GPIO3_PullUp: UCHAR,
    #[doc = " non-zero to enable pull up"]
    pub GPIO0_OpenDrain: UCHAR,
    #[doc = " non-zero to enable open drain"]
    pub GPIO1_OpenDrain: UCHAR,
    #[doc = " non-zero to enable open drain"]
    pub GPIO2_OpenDrain: UCHAR,
    #[doc = " non-zero to enable open drain"]
    pub GPIO3_OpenDrain: UCHAR,
    #[doc = " non-zero to enable open drain"]
    pub GPIO0_Suspend: UCHAR,
    #[doc = " 0 for no-change, 1 for input (not implemented on Rev A), 2 for push-low, 3 for push high"]
    pub GPIO1_Suspend: UCHAR,
    #[doc = " 0 for no-change, 1 for input (not implemented on Rev A), 2 for push-low, 3 for push high"]
    pub GPIO2_Suspend: UCHAR,
    #[doc = " 0 for no-change, 1 for input (not implemented on Rev A), 2 for push-low, 3 for push high"]
    pub GPIO3_Suspend: UCHAR,
    #[doc = " 0 for no-change, 1 for input (not implemented on Rev A), 2 for push-low, 3 for push high"]
    pub FallingEdge: UCHAR,
    #[doc = " non-zero to change GPIO on falling edge\n BCD"]
    pub BCD_Disable: UCHAR,
    #[doc = " non-zero to disable BCD"]
    pub BCD_OutputActiveLow: UCHAR,
    #[doc = " non-zero to set BCD output active low"]
    pub BCD_Drive: UCHAR,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ft_eeprom_4222h"][::std::mem::size_of::<ft_eeprom_4222h>() - 64usize];
    ["Alignment of ft_eeprom_4222h"][::std::mem::align_of::<ft_eeprom_4222h>() - 4usize];
    ["Offset of field: ft_eeprom_4222h::common"]
        [::std::mem::offset_of!(ft_eeprom_4222h, common) - 0usize];
    ["Offset of field: ft_eeprom_4222h::Revision"]
        [::std::mem::offset_of!(ft_eeprom_4222h, Revision) - 16usize];
    ["Offset of field: ft_eeprom_4222h::I2C_Slave_Address"]
        [::std::mem::offset_of!(ft_eeprom_4222h, I2C_Slave_Address) - 17usize];
    ["Offset of field: ft_eeprom_4222h::SPISuspend"]
        [::std::mem::offset_of!(ft_eeprom_4222h, SPISuspend) - 18usize];
    ["Offset of field: ft_eeprom_4222h::SuspendOutPol"]
        [::std::mem::offset_of!(ft_eeprom_4222h, SuspendOutPol) - 19usize];
    ["Offset of field: ft_eeprom_4222h::EnableSuspendOut"]
        [::std::mem::offset_of!(ft_eeprom_4222h, EnableSuspendOut) - 20usize];
    ["Offset of field: ft_eeprom_4222h::Clock_SlowSlew"]
        [::std::mem::offset_of!(ft_eeprom_4222h, Clock_SlowSlew) - 21usize];
    ["Offset of field: ft_eeprom_4222h::Clock_Drive"]
        [::std::mem::offset_of!(ft_eeprom_4222h, Clock_Drive) - 22usize];
    ["Offset of field: ft_eeprom_4222h::IO0_SlowSlew"]
        [::std::mem::offset_of!(ft_eeprom_4222h, IO0_SlowSlew) - 23usize];
    ["Offset of field: ft_eeprom_4222h::IO1_SlowSlew"]
        [::std::mem::offset_of!(ft_eeprom_4222h, IO1_SlowSlew) - 24usize];
    ["Offset of field: ft_eeprom_4222h::IO2_SlowSlew"]
        [::std::mem::offset_of!(ft_eeprom_4222h, IO2_SlowSlew) - 25usize];
    ["Offset of field: ft_eeprom_4222h::IO3_SlowSlew"]
        [::std::mem::offset_of!(ft_eeprom_4222h, IO3_SlowSlew) - 26usize];
    ["Offset of field: ft_eeprom_4222h::IO_Drive"]
        [::std::mem::offset_of!(ft_eeprom_4222h, IO_Drive) - 27usize];
    ["Offset of field: ft_eeprom_4222h::SlaveSelect_PullUp"]
        [::std::mem::offset_of!(ft_eeprom_4222h, SlaveSelect_PullUp) - 28usize];
    ["Offset of field: ft_eeprom_4222h::SlaveSelect_PullDown"]
        [::std::mem::offset_of!(ft_eeprom_4222h, SlaveSelect_PullDown) - 29usize];
    ["Offset of field: ft_eeprom_4222h::SlaveSelect_Drive"]
        [::std::mem::offset_of!(ft_eeprom_4222h, SlaveSelect_Drive) - 30usize];
    ["Offset of field: ft_eeprom_4222h::SlaveSelect_SlowSlew"]
        [::std::mem::offset_of!(ft_eeprom_4222h, SlaveSelect_SlowSlew) - 31usize];
    ["Offset of field: ft_eeprom_4222h::MISO_Suspend"]
        [::std::mem::offset_of!(ft_eeprom_4222h, MISO_Suspend) - 32usize];
    ["Offset of field: ft_eeprom_4222h::SIMO_Suspend"]
        [::std::mem::offset_of!(ft_eeprom_4222h, SIMO_Suspend) - 33usize];
    ["Offset of field: ft_eeprom_4222h::IO2_IO3_Suspend"]
        [::std::mem::offset_of!(ft_eeprom_4222h, IO2_IO3_Suspend) - 34usize];
    ["Offset of field: ft_eeprom_4222h::SlaveSelect_Suspend"]
        [::std::mem::offset_of!(ft_eeprom_4222h, SlaveSelect_Suspend) - 35usize];
    ["Offset of field: ft_eeprom_4222h::GPIO0_Drive"]
        [::std::mem::offset_of!(ft_eeprom_4222h, GPIO0_Drive) - 36usize];
    ["Offset of field: ft_eeprom_4222h::GPIO1_Drive"]
        [::std::mem::offset_of!(ft_eeprom_4222h, GPIO1_Drive) - 37usize];
    ["Offset of field: ft_eeprom_4222h::GPIO2_Drive"]
        [::std::mem::offset_of!(ft_eeprom_4222h, GPIO2_Drive) - 38usize];
    ["Offset of field: ft_eeprom_4222h::GPIO3_Drive"]
        [::std::mem::offset_of!(ft_eeprom_4222h, GPIO3_Drive) - 39usize];
    ["Offset of field: ft_eeprom_4222h::GPIO0_SlowSlew"]
        [::std::mem::offset_of!(ft_eeprom_4222h, GPIO0_SlowSlew) - 40usize];
    ["Offset of field: ft_eeprom_4222h::GPIO1_SlowSlew"]
        [::std::mem::offset_of!(ft_eeprom_4222h, GPIO1_SlowSlew) - 41usize];
    ["Offset of field: ft_eeprom_4222h::GPIO2_SlowSlew"]
        [::std::mem::offset_of!(ft_eeprom_4222h, GPIO2_SlowSlew) - 42usize];
    ["Offset of field: ft_eeprom_4222h::GPIO3_SlowSlew"]
        [::std::mem::offset_of!(ft_eeprom_4222h, GPIO3_SlowSlew) - 43usize];
    ["Offset of field: ft_eeprom_4222h::GPIO0_PullDown"]
        [::std::mem::offset_of!(ft_eeprom_4222h, GPIO0_PullDown) - 44usize];
    ["Offset of field: ft_eeprom_4222h::GPIO1_PullDown"]
        [::std::mem::offset_of!(ft_eeprom_4222h, GPIO1_PullDown) - 45usize];
    ["Offset of field: ft_eeprom_4222h::GPIO2_PullDown"]
        [::std::mem::offset_of!(ft_eeprom_4222h, GPIO2_PullDown) - 46usize];
    ["Offset of field: ft_eeprom_4222h::GPIO3_PullDown"]
        [::std::mem::offset_of!(ft_eeprom_4222h, GPIO3_PullDown) - 47usize];
    ["Offset of field: ft_eeprom_4222h::GPIO0_PullUp"]
        [::std::mem::offset_of!(ft_eeprom_4222h, GPIO0_PullUp) - 48usize];
    ["Offset of field: ft_eeprom_4222h::GPIO1_PullUp"]
        [::std::mem::offset_of!(ft_eeprom_4222h, GPIO1_PullUp) - 49usize];
    ["Offset of field: ft_eeprom_4222h::GPIO2_PullUp"]
        [::std::mem::offset_of!(ft_eeprom_4222h, GPIO2_PullUp) - 50usize];
    ["Offset of field: ft_eeprom_4222h::GPIO3_PullUp"]
        [::std::mem::offset_of!(ft_eeprom_4222h, GPIO3_PullUp) - 51usize];
    ["Offset of field: ft_eeprom_4222h::GPIO0_OpenDrain"]
        [::std::mem::offset_of!(ft_eeprom_4222h, GPIO0_OpenDrain) - 52usize];
    ["Offset of field: ft_eeprom_4222h::GPIO1_OpenDrain"]
        [::std::mem::offset_of!(ft_eeprom_4222h, GPIO1_OpenDrain) - 53usize];
    ["Offset of field: ft_eeprom_4222h::GPIO2_OpenDrain"]
        [::std::mem::offset_of!(ft_eeprom_4222h, GPIO2_OpenDrain) - 54usize];
    ["Offset of field: ft_eeprom_4222h::GPIO3_OpenDrain"]
        [::std::mem::offset_of!(ft_eeprom_4222h, GPIO3_OpenDrain) - 55usize];
    ["Offset of field: ft_eeprom_4222h::GPIO0_Suspend"]
        [::std::mem::offset_of!(ft_eeprom_4222h, GPIO0_Suspend) - 56usize];
    ["Offset of field: ft_eeprom_4222h::GPIO1_Suspend"]
        [::std::mem::offset_of!(ft_eeprom_4222h, GPIO1_Suspend) - 57usize];
    ["Offset of field: ft_eeprom_4222h::GPIO2_Suspend"]
        [::std::mem::offset_of!(ft_eeprom_4222h, GPIO2_Suspend) - 58usize];
    ["Offset of field: ft_eeprom_4222h::GPIO3_Suspend"]
        [::std::mem::offset_of!(ft_eeprom_4222h, GPIO3_Suspend) - 59usize];
    ["Offset of field: ft_eeprom_4222h::FallingEdge"]
        [::std::mem::offset_of!(ft_eeprom_4222h, FallingEdge) - 60usize];
    ["Offset of field: ft_eeprom_4222h::BCD_Disable"]
        [::std::mem::offset_of!(ft_eeprom_4222h, BCD_Disable) - 61usize];
    ["Offset of field: ft_eeprom_4222h::BCD_OutputActiveLow"]
        [::std::mem::offset_of!(ft_eeprom_4222h, BCD_OutputActiveLow) - 62usize];
    ["Offset of field: ft_eeprom_4222h::BCD_Drive"]
        [::std::mem::offset_of!(ft_eeprom_4222h, BCD_Drive) - 63usize];
};
#[doc = "  @noop FT_EEPROM_4222H\n @par Summary\n Structure to hold data for the FT4222H data in the FT_EEPROM_Program and FT_EEPROM_Read functions.\n This is appended to an FT_EEPROM_HEADER structure.\n @see FT_EEPROM_HEADER"]
pub type FT_EEPROM_4222H = ft_eeprom_4222h;
#[doc = "  @noop FT_EEPROM_PD_PDO_mv_ma\n @par Summary\n Structure to hold PDO Configuration structure, mA supported values 0 to 10230mA, mV supported\n values 0 to 51100mV. This is part of the FT_EEPROM_PD structure.\n @see FT_EEPROM_PD"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ft_eeprom_PD_PDO_mv_ma {
    pub PDO1ma: USHORT,
    #[doc = " PDO1 mA"]
    pub PDO1mv: USHORT,
    #[doc = " PDO1 mV"]
    pub PDO2ma: USHORT,
    #[doc = " PDO2 mA"]
    pub PDO2mv: USHORT,
    #[doc = " PDO2 mV"]
    pub PDO3ma: USHORT,
    #[doc = " PDO3 mA"]
    pub PDO3mv: USHORT,
    #[doc = " PDO3 mV"]
    pub PDO4ma: USHORT,
    #[doc = " PDO4 mA"]
    pub PDO4mv: USHORT,
    #[doc = " PDO4 mV"]
    pub PDO5ma: USHORT,
    #[doc = " PDO5 mA (FTx233HP only)"]
    pub PDO5mv: USHORT,
    #[doc = " PDO5 mV (FTx233HP only)"]
    pub PDO6ma: USHORT,
    #[doc = " PDO6 mA (FTx233HP only)"]
    pub PDO6mv: USHORT,
    #[doc = " PDO6 mV (FTx233HP only)"]
    pub PDO7ma: USHORT,
    #[doc = " PDO7 mA (FTx233HP only)"]
    pub PDO7mv: USHORT,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ft_eeprom_PD_PDO_mv_ma"][::std::mem::size_of::<ft_eeprom_PD_PDO_mv_ma>() - 28usize];
    ["Alignment of ft_eeprom_PD_PDO_mv_ma"]
        [::std::mem::align_of::<ft_eeprom_PD_PDO_mv_ma>() - 2usize];
    ["Offset of field: ft_eeprom_PD_PDO_mv_ma::PDO1ma"]
        [::std::mem::offset_of!(ft_eeprom_PD_PDO_mv_ma, PDO1ma) - 0usize];
    ["Offset of field: ft_eeprom_PD_PDO_mv_ma::PDO1mv"]
        [::std::mem::offset_of!(ft_eeprom_PD_PDO_mv_ma, PDO1mv) - 2usize];
    ["Offset of field: ft_eeprom_PD_PDO_mv_ma::PDO2ma"]
        [::std::mem::offset_of!(ft_eeprom_PD_PDO_mv_ma, PDO2ma) - 4usize];
    ["Offset of field: ft_eeprom_PD_PDO_mv_ma::PDO2mv"]
        [::std::mem::offset_of!(ft_eeprom_PD_PDO_mv_ma, PDO2mv) - 6usize];
    ["Offset of field: ft_eeprom_PD_PDO_mv_ma::PDO3ma"]
        [::std::mem::offset_of!(ft_eeprom_PD_PDO_mv_ma, PDO3ma) - 8usize];
    ["Offset of field: ft_eeprom_PD_PDO_mv_ma::PDO3mv"]
        [::std::mem::offset_of!(ft_eeprom_PD_PDO_mv_ma, PDO3mv) - 10usize];
    ["Offset of field: ft_eeprom_PD_PDO_mv_ma::PDO4ma"]
        [::std::mem::offset_of!(ft_eeprom_PD_PDO_mv_ma, PDO4ma) - 12usize];
    ["Offset of field: ft_eeprom_PD_PDO_mv_ma::PDO4mv"]
        [::std::mem::offset_of!(ft_eeprom_PD_PDO_mv_ma, PDO4mv) - 14usize];
    ["Offset of field: ft_eeprom_PD_PDO_mv_ma::PDO5ma"]
        [::std::mem::offset_of!(ft_eeprom_PD_PDO_mv_ma, PDO5ma) - 16usize];
    ["Offset of field: ft_eeprom_PD_PDO_mv_ma::PDO5mv"]
        [::std::mem::offset_of!(ft_eeprom_PD_PDO_mv_ma, PDO5mv) - 18usize];
    ["Offset of field: ft_eeprom_PD_PDO_mv_ma::PDO6ma"]
        [::std::mem::offset_of!(ft_eeprom_PD_PDO_mv_ma, PDO6ma) - 20usize];
    ["Offset of field: ft_eeprom_PD_PDO_mv_ma::PDO6mv"]
        [::std::mem::offset_of!(ft_eeprom_PD_PDO_mv_ma, PDO6mv) - 22usize];
    ["Offset of field: ft_eeprom_PD_PDO_mv_ma::PDO7ma"]
        [::std::mem::offset_of!(ft_eeprom_PD_PDO_mv_ma, PDO7ma) - 24usize];
    ["Offset of field: ft_eeprom_PD_PDO_mv_ma::PDO7mv"]
        [::std::mem::offset_of!(ft_eeprom_PD_PDO_mv_ma, PDO7mv) - 26usize];
};
#[doc = "  @noop FT_EEPROM_PD_PDO_mv_ma\n @par Summary\n Structure to hold PDO Configuration structure, mA supported values 0 to 10230mA, mV supported\n values 0 to 51100mV. This is part of the FT_EEPROM_PD structure.\n @see FT_EEPROM_PD"]
pub type FT_EEPROM_PD_PDO_mv_ma = ft_eeprom_PD_PDO_mv_ma;
#[doc = "  @noop FT_EEPROM_PD\n @par Summary\n Structure to hold power delivery configuration data for the FT4233PD, FT2233PD, FT4232PD,\n FT2232PD, FT233PD and FT232PD in the FT_EEPROM_Program and FT_EEPROM_Read functions.\n This is appended to an FT_EEPROM_HEADER and a base device structure.\n e_g. @verbatim\n\t\tstruct {\n\t\t\tFT_EEPROM_xxx base;\n\t\t\tFT_EEPROM_PD pd;\n\t\t};\n @endverbatim\n @remarks\n Device GPIO values are:\n @li\tFTx233HP - 0 to 7, 15 for N/A\n @li FTx232HP - 0 to 3, 15 for N/A\n @see FT_EEPROM_HEADER\n @see FT_EEPROM_PD_PDO_mv_ma"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ft_eeprom_pd {
    #[doc = " Configuration"]
    pub srprs: UCHAR,
    #[doc = " non-zero to enable Sink Request Power Role Swap"]
    pub sraprs: UCHAR,
    #[doc = " non-zero to enable Sink Accept PR Swap"]
    pub srrprs: UCHAR,
    #[doc = " non-zero to enable Source Request PR SWAP"]
    pub saprs: UCHAR,
    #[doc = " non-zero to enable Source Accept PR SWAP"]
    pub vconns: UCHAR,
    #[doc = " non-zero to enable vConn Swap"]
    pub passthru: UCHAR,
    #[doc = " non-zero to enable Pass Through (FTx233HP only)"]
    pub extmcu: UCHAR,
    #[doc = " non-zero to enable External MCU"]
    pub pd2en: UCHAR,
    #[doc = " non-zero to enable PD2 (FTx233HP only)"]
    pub pd1autoclk: UCHAR,
    #[doc = " non-zero to enable PD1 Auto Clock"]
    pub pd2autoclk: UCHAR,
    #[doc = " non-zero to enable PD2 Auto Clock (FTx233HP only)"]
    pub useefuse: UCHAR,
    #[doc = " non-zero to Use EFUSE"]
    pub extvconn: UCHAR,
    #[doc = " GPIO Configuration"]
    pub count: UCHAR,
    #[doc = " GPIO Count, supported values are 0 to 7"]
    pub gpio1: UCHAR,
    #[doc = " GPIO Number 1, supports device GPIO values"]
    pub gpio2: UCHAR,
    #[doc = " GPIO Number 2, supports device GPIO values"]
    pub gpio3: UCHAR,
    #[doc = " GPIO Number 3, supports device GPIO values"]
    pub gpio4: UCHAR,
    #[doc = " GPIO Number 4, supports device GPIO values"]
    pub gpio5: UCHAR,
    #[doc = " GPIO Number 5, supports device GPIO values (FTx233HP only)"]
    pub gpio6: UCHAR,
    #[doc = " GPIO Number 6, supports device GPIO values (FTx233HP only)"]
    pub gpio7: UCHAR,
    #[doc = " GPIO Number 7, supports device GPIO values (FTx233HP only)"]
    pub pd1lden: UCHAR,
    #[doc = " PD1 Load Enable, supports device GPIO values"]
    pub pd2lden: UCHAR,
    #[doc = " PD2 Load Enable, supports device GPIO values (FTx233HP only)"]
    pub dispin: UCHAR,
    #[doc = " Discharge Pin, supports device GPIO values"]
    pub disenbm: UCHAR,
    #[doc = " Discharge Enable BM, 0 for \"Drive Hi\", 1 for \"Drive Low\", 2 for \"Input Mode\", 3 for \"Don't Care\""]
    pub disdisbm: UCHAR,
    #[doc = " Discharge Disable BM, 0 for \"Drive Hi\", 1 for \"Drive Low\", 2 for \"Input Mode\", 3 for \"Don't Care\""]
    pub ccselect: UCHAR,
    #[doc = " ISET Configuration"]
    pub iset1: UCHAR,
    #[doc = " ISET1, supports device GPIO values"]
    pub iset2: UCHAR,
    #[doc = " ISET2, supports device GPIO values"]
    pub iset3: UCHAR,
    #[doc = " ISET3, supports device GPIO values"]
    pub extiset: UCHAR,
    #[doc = " non-zero to enable EXTEND_ISET"]
    pub isetpd2: UCHAR,
    #[doc = " non-zero to enable ISET_PD2"]
    pub iseten: UCHAR,
    #[doc = " BM Configuration, 0 for \"Drive Hi\", 1 for \"Drive Low\", 2 for \"Input Mode\", 3 for \"Don't Care\""]
    pub PDO1_GPIO: [UCHAR; 7usize],
    #[doc = " PDO1 GPIO1 to GPIO7"]
    pub PDO2_GPIO: [UCHAR; 7usize],
    #[doc = " PDO2 GPIO1 to GPIO7"]
    pub PDO3_GPIO: [UCHAR; 7usize],
    #[doc = " PDO3 GPIO1 to GPIO7"]
    pub PDO4_GPIO: [UCHAR; 7usize],
    #[doc = " PDO4 GPIO1 to GPIO7"]
    pub PDO5_GPIO: [UCHAR; 7usize],
    #[doc = " PDO5 GPIO1 to GPIO7 (FTx233HP only)"]
    pub PDO6_GPIO: [UCHAR; 7usize],
    #[doc = " PDO6 GPIO1 to GPIO7 (FTx233HP only)"]
    pub PDO7_GPIO: [UCHAR; 7usize],
    #[doc = " PDO7 GPIO1 to GPIO7 (FTx233HP only)"]
    pub VSET0V_GPIO: [UCHAR; 7usize],
    #[doc = " PDO7 GPIO1 to GPIO7"]
    pub VSAFE5V_GPIO: [UCHAR; 7usize],
    #[doc = " PDO7 GPIO1 to GPIO7"]
    pub BM_PDO_Sink: FT_EEPROM_PD_PDO_mv_ma,
    pub BM_PDO_Source: FT_EEPROM_PD_PDO_mv_ma,
    pub BM_PDO_Sink_2: FT_EEPROM_PD_PDO_mv_ma,
    #[doc = " PD Timers"]
    pub srt: UCHAR,
    #[doc = " Sender Response Timer"]
    pub hrt: UCHAR,
    #[doc = " Hard Reset Timer"]
    pub sct: UCHAR,
    #[doc = " Source Capability Timer"]
    pub dit: UCHAR,
    #[doc = " Discover Identity Timer"]
    pub srcrt: USHORT,
    #[doc = " Source Recover Timer"]
    pub trt: USHORT,
    #[doc = " Transition Timer"]
    pub sofft: USHORT,
    #[doc = " Source off timer"]
    pub nrt: USHORT,
    #[doc = " No Response Timer"]
    pub swct: USHORT,
    #[doc = " Sink Wait Capability Timer"]
    pub snkrt: USHORT,
    #[doc = " Sink Request Timer"]
    pub dt: UCHAR,
    #[doc = " Discharge Timer"]
    pub cnst: UCHAR,
    #[doc = " Chunk not supported timer"]
    pub it: USHORT,
    #[doc = " PD Control"]
    pub i2caddr: UCHAR,
    #[doc = " I2C Address (hex)"]
    pub prou: UINT,
    #[doc = " Power Reserved for OWN use"]
    pub trim1: UINT,
    #[doc = " TRIM1"]
    pub trim2: UINT,
    #[doc = " TRIM2"]
    pub extdc: UCHAR,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ft_eeprom_pd"][::std::mem::size_of::<ft_eeprom_pd>() - 220usize];
    ["Alignment of ft_eeprom_pd"][::std::mem::align_of::<ft_eeprom_pd>() - 4usize];
    ["Offset of field: ft_eeprom_pd::srprs"][::std::mem::offset_of!(ft_eeprom_pd, srprs) - 0usize];
    ["Offset of field: ft_eeprom_pd::sraprs"]
        [::std::mem::offset_of!(ft_eeprom_pd, sraprs) - 1usize];
    ["Offset of field: ft_eeprom_pd::srrprs"]
        [::std::mem::offset_of!(ft_eeprom_pd, srrprs) - 2usize];
    ["Offset of field: ft_eeprom_pd::saprs"][::std::mem::offset_of!(ft_eeprom_pd, saprs) - 3usize];
    ["Offset of field: ft_eeprom_pd::vconns"]
        [::std::mem::offset_of!(ft_eeprom_pd, vconns) - 4usize];
    ["Offset of field: ft_eeprom_pd::passthru"]
        [::std::mem::offset_of!(ft_eeprom_pd, passthru) - 5usize];
    ["Offset of field: ft_eeprom_pd::extmcu"]
        [::std::mem::offset_of!(ft_eeprom_pd, extmcu) - 6usize];
    ["Offset of field: ft_eeprom_pd::pd2en"][::std::mem::offset_of!(ft_eeprom_pd, pd2en) - 7usize];
    ["Offset of field: ft_eeprom_pd::pd1autoclk"]
        [::std::mem::offset_of!(ft_eeprom_pd, pd1autoclk) - 8usize];
    ["Offset of field: ft_eeprom_pd::pd2autoclk"]
        [::std::mem::offset_of!(ft_eeprom_pd, pd2autoclk) - 9usize];
    ["Offset of field: ft_eeprom_pd::useefuse"]
        [::std::mem::offset_of!(ft_eeprom_pd, useefuse) - 10usize];
    ["Offset of field: ft_eeprom_pd::extvconn"]
        [::std::mem::offset_of!(ft_eeprom_pd, extvconn) - 11usize];
    ["Offset of field: ft_eeprom_pd::count"][::std::mem::offset_of!(ft_eeprom_pd, count) - 12usize];
    ["Offset of field: ft_eeprom_pd::gpio1"][::std::mem::offset_of!(ft_eeprom_pd, gpio1) - 13usize];
    ["Offset of field: ft_eeprom_pd::gpio2"][::std::mem::offset_of!(ft_eeprom_pd, gpio2) - 14usize];
    ["Offset of field: ft_eeprom_pd::gpio3"][::std::mem::offset_of!(ft_eeprom_pd, gpio3) - 15usize];
    ["Offset of field: ft_eeprom_pd::gpio4"][::std::mem::offset_of!(ft_eeprom_pd, gpio4) - 16usize];
    ["Offset of field: ft_eeprom_pd::gpio5"][::std::mem::offset_of!(ft_eeprom_pd, gpio5) - 17usize];
    ["Offset of field: ft_eeprom_pd::gpio6"][::std::mem::offset_of!(ft_eeprom_pd, gpio6) - 18usize];
    ["Offset of field: ft_eeprom_pd::gpio7"][::std::mem::offset_of!(ft_eeprom_pd, gpio7) - 19usize];
    ["Offset of field: ft_eeprom_pd::pd1lden"]
        [::std::mem::offset_of!(ft_eeprom_pd, pd1lden) - 20usize];
    ["Offset of field: ft_eeprom_pd::pd2lden"]
        [::std::mem::offset_of!(ft_eeprom_pd, pd2lden) - 21usize];
    ["Offset of field: ft_eeprom_pd::dispin"]
        [::std::mem::offset_of!(ft_eeprom_pd, dispin) - 22usize];
    ["Offset of field: ft_eeprom_pd::disenbm"]
        [::std::mem::offset_of!(ft_eeprom_pd, disenbm) - 23usize];
    ["Offset of field: ft_eeprom_pd::disdisbm"]
        [::std::mem::offset_of!(ft_eeprom_pd, disdisbm) - 24usize];
    ["Offset of field: ft_eeprom_pd::ccselect"]
        [::std::mem::offset_of!(ft_eeprom_pd, ccselect) - 25usize];
    ["Offset of field: ft_eeprom_pd::iset1"][::std::mem::offset_of!(ft_eeprom_pd, iset1) - 26usize];
    ["Offset of field: ft_eeprom_pd::iset2"][::std::mem::offset_of!(ft_eeprom_pd, iset2) - 27usize];
    ["Offset of field: ft_eeprom_pd::iset3"][::std::mem::offset_of!(ft_eeprom_pd, iset3) - 28usize];
    ["Offset of field: ft_eeprom_pd::extiset"]
        [::std::mem::offset_of!(ft_eeprom_pd, extiset) - 29usize];
    ["Offset of field: ft_eeprom_pd::isetpd2"]
        [::std::mem::offset_of!(ft_eeprom_pd, isetpd2) - 30usize];
    ["Offset of field: ft_eeprom_pd::iseten"]
        [::std::mem::offset_of!(ft_eeprom_pd, iseten) - 31usize];
    ["Offset of field: ft_eeprom_pd::PDO1_GPIO"]
        [::std::mem::offset_of!(ft_eeprom_pd, PDO1_GPIO) - 32usize];
    ["Offset of field: ft_eeprom_pd::PDO2_GPIO"]
        [::std::mem::offset_of!(ft_eeprom_pd, PDO2_GPIO) - 39usize];
    ["Offset of field: ft_eeprom_pd::PDO3_GPIO"]
        [::std::mem::offset_of!(ft_eeprom_pd, PDO3_GPIO) - 46usize];
    ["Offset of field: ft_eeprom_pd::PDO4_GPIO"]
        [::std::mem::offset_of!(ft_eeprom_pd, PDO4_GPIO) - 53usize];
    ["Offset of field: ft_eeprom_pd::PDO5_GPIO"]
        [::std::mem::offset_of!(ft_eeprom_pd, PDO5_GPIO) - 60usize];
    ["Offset of field: ft_eeprom_pd::PDO6_GPIO"]
        [::std::mem::offset_of!(ft_eeprom_pd, PDO6_GPIO) - 67usize];
    ["Offset of field: ft_eeprom_pd::PDO7_GPIO"]
        [::std::mem::offset_of!(ft_eeprom_pd, PDO7_GPIO) - 74usize];
    ["Offset of field: ft_eeprom_pd::VSET0V_GPIO"]
        [::std::mem::offset_of!(ft_eeprom_pd, VSET0V_GPIO) - 81usize];
    ["Offset of field: ft_eeprom_pd::VSAFE5V_GPIO"]
        [::std::mem::offset_of!(ft_eeprom_pd, VSAFE5V_GPIO) - 88usize];
    ["Offset of field: ft_eeprom_pd::BM_PDO_Sink"]
        [::std::mem::offset_of!(ft_eeprom_pd, BM_PDO_Sink) - 96usize];
    ["Offset of field: ft_eeprom_pd::BM_PDO_Source"]
        [::std::mem::offset_of!(ft_eeprom_pd, BM_PDO_Source) - 124usize];
    ["Offset of field: ft_eeprom_pd::BM_PDO_Sink_2"]
        [::std::mem::offset_of!(ft_eeprom_pd, BM_PDO_Sink_2) - 152usize];
    ["Offset of field: ft_eeprom_pd::srt"][::std::mem::offset_of!(ft_eeprom_pd, srt) - 180usize];
    ["Offset of field: ft_eeprom_pd::hrt"][::std::mem::offset_of!(ft_eeprom_pd, hrt) - 181usize];
    ["Offset of field: ft_eeprom_pd::sct"][::std::mem::offset_of!(ft_eeprom_pd, sct) - 182usize];
    ["Offset of field: ft_eeprom_pd::dit"][::std::mem::offset_of!(ft_eeprom_pd, dit) - 183usize];
    ["Offset of field: ft_eeprom_pd::srcrt"]
        [::std::mem::offset_of!(ft_eeprom_pd, srcrt) - 184usize];
    ["Offset of field: ft_eeprom_pd::trt"][::std::mem::offset_of!(ft_eeprom_pd, trt) - 186usize];
    ["Offset of field: ft_eeprom_pd::sofft"]
        [::std::mem::offset_of!(ft_eeprom_pd, sofft) - 188usize];
    ["Offset of field: ft_eeprom_pd::nrt"][::std::mem::offset_of!(ft_eeprom_pd, nrt) - 190usize];
    ["Offset of field: ft_eeprom_pd::swct"][::std::mem::offset_of!(ft_eeprom_pd, swct) - 192usize];
    ["Offset of field: ft_eeprom_pd::snkrt"]
        [::std::mem::offset_of!(ft_eeprom_pd, snkrt) - 194usize];
    ["Offset of field: ft_eeprom_pd::dt"][::std::mem::offset_of!(ft_eeprom_pd, dt) - 196usize];
    ["Offset of field: ft_eeprom_pd::cnst"][::std::mem::offset_of!(ft_eeprom_pd, cnst) - 197usize];
    ["Offset of field: ft_eeprom_pd::it"][::std::mem::offset_of!(ft_eeprom_pd, it) - 198usize];
    ["Offset of field: ft_eeprom_pd::i2caddr"]
        [::std::mem::offset_of!(ft_eeprom_pd, i2caddr) - 200usize];
    ["Offset of field: ft_eeprom_pd::prou"][::std::mem::offset_of!(ft_eeprom_pd, prou) - 204usize];
    ["Offset of field: ft_eeprom_pd::trim1"]
        [::std::mem::offset_of!(ft_eeprom_pd, trim1) - 208usize];
    ["Offset of field: ft_eeprom_pd::trim2"]
        [::std::mem::offset_of!(ft_eeprom_pd, trim2) - 212usize];
    ["Offset of field: ft_eeprom_pd::extdc"]
        [::std::mem::offset_of!(ft_eeprom_pd, extdc) - 216usize];
};
#[doc = "  @noop FT_EEPROM_PD\n @par Summary\n Structure to hold power delivery configuration data for the FT4233PD, FT2233PD, FT4232PD,\n FT2232PD, FT233PD and FT232PD in the FT_EEPROM_Program and FT_EEPROM_Read functions.\n This is appended to an FT_EEPROM_HEADER and a base device structure.\n e_g. @verbatim\n\t\tstruct {\n\t\t\tFT_EEPROM_xxx base;\n\t\t\tFT_EEPROM_PD pd;\n\t\t};\n @endverbatim\n @remarks\n Device GPIO values are:\n @li\tFTx233HP - 0 to 7, 15 for N/A\n @li FTx232HP - 0 to 3, 15 for N/A\n @see FT_EEPROM_HEADER\n @see FT_EEPROM_PD_PDO_mv_ma"]
pub type FT_EEPROM_PD = ft_eeprom_pd;
#[doc = " FT2233HP EEPROM structure for use with FT_EEPROM_Read and FT_EEPROM_Program\n FT2232H with power delivery"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ft_eeprom_2233hp {
    pub ft2232h: FT_EEPROM_2232H,
    pub pd: FT_EEPROM_PD,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ft_eeprom_2233hp"][::std::mem::size_of::<_ft_eeprom_2233hp>() - 260usize];
    ["Alignment of _ft_eeprom_2233hp"][::std::mem::align_of::<_ft_eeprom_2233hp>() - 4usize];
    ["Offset of field: _ft_eeprom_2233hp::ft2232h"]
        [::std::mem::offset_of!(_ft_eeprom_2233hp, ft2232h) - 0usize];
    ["Offset of field: _ft_eeprom_2233hp::pd"]
        [::std::mem::offset_of!(_ft_eeprom_2233hp, pd) - 40usize];
};
#[doc = " FT2233HP EEPROM structure for use with FT_EEPROM_Read and FT_EEPROM_Program\n FT2232H with power delivery"]
pub type FT_EEPROM_2233HP = _ft_eeprom_2233hp;
#[doc = " FT4233HP EEPROM structure for use with FT_EEPROM_Read and FT_EEPROM_Program\n FT4232H with power delivery"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ft_eeprom_4233hp {
    pub ft4232h: FT_EEPROM_4232H,
    pub pd: FT_EEPROM_PD,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ft_eeprom_4233hp"][::std::mem::size_of::<_ft_eeprom_4233hp>() - 256usize];
    ["Alignment of _ft_eeprom_4233hp"][::std::mem::align_of::<_ft_eeprom_4233hp>() - 4usize];
    ["Offset of field: _ft_eeprom_4233hp::ft4232h"]
        [::std::mem::offset_of!(_ft_eeprom_4233hp, ft4232h) - 0usize];
    ["Offset of field: _ft_eeprom_4233hp::pd"]
        [::std::mem::offset_of!(_ft_eeprom_4233hp, pd) - 36usize];
};
#[doc = " FT4233HP EEPROM structure for use with FT_EEPROM_Read and FT_EEPROM_Program\n FT4232H with power delivery"]
pub type FT_EEPROM_4233HP = _ft_eeprom_4233hp;
#[doc = " FT2232HP EEPROM structure for use with FT_EEPROM_Read and FT_EEPROM_Program\n FT2232H with power delivery"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ft_eeprom_2232hp {
    pub ft2232h: FT_EEPROM_2232H,
    pub pd: FT_EEPROM_PD,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ft_eeprom_2232hp"][::std::mem::size_of::<_ft_eeprom_2232hp>() - 260usize];
    ["Alignment of _ft_eeprom_2232hp"][::std::mem::align_of::<_ft_eeprom_2232hp>() - 4usize];
    ["Offset of field: _ft_eeprom_2232hp::ft2232h"]
        [::std::mem::offset_of!(_ft_eeprom_2232hp, ft2232h) - 0usize];
    ["Offset of field: _ft_eeprom_2232hp::pd"]
        [::std::mem::offset_of!(_ft_eeprom_2232hp, pd) - 40usize];
};
#[doc = " FT2232HP EEPROM structure for use with FT_EEPROM_Read and FT_EEPROM_Program\n FT2232H with power delivery"]
pub type FT_EEPROM_2232HP = _ft_eeprom_2232hp;
#[doc = " FT4232HP EEPROM structure for use with FT_EEPROM_Read and FT_EEPROM_Program\n FT4232H with power delivery"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ft_eeprom_4232hp {
    pub ft4232h: FT_EEPROM_4232H,
    pub pd: FT_EEPROM_PD,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ft_eeprom_4232hp"][::std::mem::size_of::<_ft_eeprom_4232hp>() - 256usize];
    ["Alignment of _ft_eeprom_4232hp"][::std::mem::align_of::<_ft_eeprom_4232hp>() - 4usize];
    ["Offset of field: _ft_eeprom_4232hp::ft4232h"]
        [::std::mem::offset_of!(_ft_eeprom_4232hp, ft4232h) - 0usize];
    ["Offset of field: _ft_eeprom_4232hp::pd"]
        [::std::mem::offset_of!(_ft_eeprom_4232hp, pd) - 36usize];
};
#[doc = " FT4232HP EEPROM structure for use with FT_EEPROM_Read and FT_EEPROM_Program\n FT4232H with power delivery"]
pub type FT_EEPROM_4232HP = _ft_eeprom_4232hp;
#[doc = " FT233HP EEPROM structure for use with FT_EEPROM_Read and FT_EEPROM_Program\n FT233H with power delivery"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ft_eeprom_233hp {
    pub ft232h: FT_EEPROM_232H,
    pub pd: FT_EEPROM_PD,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ft_eeprom_233hp"][::std::mem::size_of::<_ft_eeprom_233hp>() - 264usize];
    ["Alignment of _ft_eeprom_233hp"][::std::mem::align_of::<_ft_eeprom_233hp>() - 4usize];
    ["Offset of field: _ft_eeprom_233hp::ft232h"]
        [::std::mem::offset_of!(_ft_eeprom_233hp, ft232h) - 0usize];
    ["Offset of field: _ft_eeprom_233hp::pd"]
        [::std::mem::offset_of!(_ft_eeprom_233hp, pd) - 44usize];
};
#[doc = " FT233HP EEPROM structure for use with FT_EEPROM_Read and FT_EEPROM_Program\n FT233H with power delivery"]
pub type FT_EEPROM_233HP = _ft_eeprom_233hp;
#[doc = " FT232HP EEPROM structure for use with FT_EEPROM_Read and FT_EEPROM_Program\n FT232H with power delivery"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ft_eeprom_232hp {
    pub ft232h: FT_EEPROM_232H,
    pub pd: FT_EEPROM_PD,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ft_eeprom_232hp"][::std::mem::size_of::<_ft_eeprom_232hp>() - 264usize];
    ["Alignment of _ft_eeprom_232hp"][::std::mem::align_of::<_ft_eeprom_232hp>() - 4usize];
    ["Offset of field: _ft_eeprom_232hp::ft232h"]
        [::std::mem::offset_of!(_ft_eeprom_232hp, ft232h) - 0usize];
    ["Offset of field: _ft_eeprom_232hp::pd"]
        [::std::mem::offset_of!(_ft_eeprom_232hp, pd) - 44usize];
};
#[doc = " FT232HP EEPROM structure for use with FT_EEPROM_Read and FT_EEPROM_Program\n FT232H with power delivery"]
pub type FT_EEPROM_232HP = _ft_eeprom_232hp;
unsafe extern "C" {
    #[doc = " @noop FT_EEPROM_Read\n @par Supported Operating Systems\n Linux\n Mac OS X (10.4 and later)\n Windows (XP and later)\n @par Summary\n Read data from the EEPROM, this command will work for all existing FTDI chipset, and must be\n used for the FT-X series.\n @param ftHandle Handle of the device.\n @param *eepromData Pointer to a buffer that contains the data to be read.\n Note: This structure is different for each device type.\n @param eepromDataSize Size of the eepromData buffer that contains storage for the data to be read.\n @param *Manufacturer Pointer to a null-terminated string containing the manufacturer\tname.\n @param *ManufacturerId Pointer to a null-terminated string containing the manufacturer ID.\n @param *Description Pointer to a null-terminated string containing the device description.\n @param *SerialNumber Pointer to a null-terminated string containing the device serial number.\n @returns\n FT_OK if successful, otherwise the return value is an FT error code.\n @remarks\n This function interprets the parameter *eepromDATA as a pointer to a structure matching the device\n type being accessed e.g.\n @li PFT_EEPROM_232B is the structure for FT2xxB devices.\n @li PFT_EEPROM_2232 is the structure for FT2232D devices.\n @li PFT_EEPROM_232R is the structure for FT232R devices.\n @li PFT_EEPROM_2232H is the structure for FT2232H devices.\n @li PFT_EEPROM_4232H is the structure for FT4232H devices.\n @li PFT_EEPROM_232H is the structure for FT232H devices.\n @li PFT_EEPROM_X_SERIES is the structure for FT2xxX devices.\n\n The function does not perform any checks on buffer sizes, so the buffers passed in the eepromDATA\n structure must be big enough to accommodate their respective strings (including null terminators).\n The sizes shown in the following example are more than adequate and can be rounded down if necessary.\n The restriction is that the Manufacturer string length plus the Description string length is less than or\n equal to 40 characters.\n @note Note that the DLL must be informed which version of the eepromDATA structure is being used. This is\n done through the PFT_EEPROM_HEADER structure. The first element of this structure is deviceType and\n may be FT_DEVICE_BM, FT_DEVICE_AM, FT_DEVICE_2232C, FT_DEVICE_232R, FT_DEVICE_2232H,\n FT_DEVICE_4232H, FT_DEVICE_232H, or FT_DEVICE_X_SERIES as defined in FTD2XX.h."]
    pub fn FT_EEPROM_Read(
        ftHandle: FT_HANDLE,
        eepromData: *mut ::std::os::raw::c_void,
        eepromDataSize: DWORD,
        Manufacturer: *mut ::std::os::raw::c_char,
        ManufacturerId: *mut ::std::os::raw::c_char,
        Description: *mut ::std::os::raw::c_char,
        SerialNumber: *mut ::std::os::raw::c_char,
    ) -> FT_STATUS;
}
unsafe extern "C" {
    #[doc = " @noop FT_EEPROM_Program\n @par Supported Operating Systems\n Linux\n Mac OS X (10.4 and later)\n Windows (XP and later)\n @par Summary\n Write data into the EEPROM, this command will work for all existing FTDI chipset, and must be used for\n the FT-X series.\n @param ftHandle Handle of the device.\n @param *eepromData Pointer to a buffer that contains the data to be written.\n Note: This structure is different for each device type.\n @param eepromDataSize Size of the eepromData buffer that contains storage for the data to be written.\n @param *Manufacturer Pointer to a null-terminated string containing the manufacturer name.\n @param *ManufacturerId Pointer to a null-terminated string containing the manufacturer ID.\n @param *Description Pointer to a null-terminated string containing the device description.\n @param *SerialNumber Pointer to a null-terminated string containing the device serial number.\n @returns\n FT_OK if successful, otherwise the return value is an FT error code.\n @remarks\n This function interprets the parameter *eepromDATA as a pointer to a structure matching the device\n type being accessed e.g.\n @li PFT_EEPROM_232B is the structure for FT2xxB devices.\n @li PFT_EEPROM_2232 is the structure for FT2232D devices.\n @li PFT_EEPROM_232R is the structure for FT232R devices.\n @li PFT_EEPROM_2232H is the structure for FT2232H devices.\n @li PFT_EEPROM_4232H is the structure for FT4232H devices.\n @li PFT_EEPROM_232H is the structure for FT232H devices.\n @li PFT_EEPROM_X_SERIES is the structure for FT2xxX devices.\n\n The function does not perform any checks on buffer sizes, so the buffers passed in the eepromDATA\n structure must be big enough to accommodate their respective strings (including null terminators).\n @n The sizes shown in the following example are more than adequate and can be rounded down if necessary.\n The restriction is that the Manufacturer string length plus the Description string length is less than or\n equal to 40 characters.\n @note Note that the DLL must be informed which version of the eepromDATA structure is being used. This is\n done through the PFT_EEPROM_HEADER structure. The first element of this structure is deviceType and\n may be FT_DEVICE_BM, FT_DEVICE_AM, FT_DEVICE_2232C, FT_DEVICE_232R, FT_DEVICE_2232H,\n FT_DEVICE_4232H, FT_DEVICE_232H, or FT_DEVICE_X_SERIES as defined in FTD2XX.h."]
    pub fn FT_EEPROM_Program(
        ftHandle: FT_HANDLE,
        eepromData: *mut ::std::os::raw::c_void,
        eepromDataSize: DWORD,
        Manufacturer: *mut ::std::os::raw::c_char,
        ManufacturerId: *mut ::std::os::raw::c_char,
        Description: *mut ::std::os::raw::c_char,
        SerialNumber: *mut ::std::os::raw::c_char,
    ) -> FT_STATUS;
}
unsafe extern "C" {
    #[doc = " @noop FT_SetLatencyTimer\n @par Supported Operating Systems\n Linux\n Mac OS X (10.4 and later)\n Windows (2000 and later)\n Windows CE (4.2 and later)\n @par Summary\n Set the latency timer value.\n @param ftHandle Handle of the device.\n @param ucLatency Required value, in milliseconds, of latency timer. Valid range is 2 - 255.\n @returns\n FT_OK if successful, otherwise the return value is an FT error code.\n @remarks\n In the FT8U232AM and FT8U245AM devices, the receive buffer timeout that is used to flush remaining\n data from the receive buffer was fixed at 16 ms. In all other FTDI devices, this timeout is\n programmable and can be set at 1 ms intervals between 2ms and 255 ms. This allows the device to\n be better optimize for protocols requiring faster response times from short data packets."]
    pub fn FT_SetLatencyTimer(ftHandle: FT_HANDLE, ucLatency: UCHAR) -> FT_STATUS;
}
unsafe extern "C" {
    #[doc = " @noop FT_GetLatencyTimer\n @par Supported Operating Systems\n Linux\n Mac OS X (10.4 and later)\n Windows (2000 and later)\n Windows CE (4.2 and later)\n @par Summary\n Get the current value of the latency timer.\n @param ftHandle Handle of the device.\n @param pucLatency Pointer to unsigned char to store latency timer value.\n @returns\n FT_OK if successful, otherwise the return value is an FT error code.\n @remarks\n In the FT8U232AM and FT8U245AM devices, the receive buffer timeout that is used to flush remaining\n data from the receive buffer was fixed at 16 ms. In all other FTDI devices, this timeout is\n programmable and can be set at 1 ms intervals between 2ms and 255 ms. This allows the device to\n be better optimized for protocols requiring faster response times from short data packets."]
    pub fn FT_GetLatencyTimer(ftHandle: FT_HANDLE, pucLatency: PUCHAR) -> FT_STATUS;
}
unsafe extern "C" {
    #[doc = " @noop FT_SetBitMode\n @par Supported Operating Systems\n Linux\n Mac OS X (10.4 and later)\n Windows (2000 and later)\n Windows CE (4.2 and later)\n @par Summary\n Enables different chip modes.\n @param ftHandle Handle of the device.\n @param ucMask Required value for bit mode mask. This sets up which bits are inputs and outputs.\n A bit value of 0 sets the corresponding pin to an input, a bit value of 1 sets the corresponding\n pin to an output.\n @n In the case of CBUS Bit Bang, the upper nibble of this value controls which pins are inputs\n and outputs,\twhile the lower nibble controls which of the outputs are high and low.\n @param ucEnable Mode value. Can be one of the following:\n @li 0x0 = Reset\n @li 0x1 = Asynchronous Bit Bang\n @li 0x2 = MPSSE (FT2232, FT2232H, FT4232H and FT232H devices only)\n @li 0x4 = Synchronous Bit Bang (FT232R, FT245R, FT2232, FT2232H, FT4232H and FT232H devices only)\n @li 0x8 = MCU Host Bus Emulation Mode (FT2232, FT2232H, FT4232H and FT232H devices only)\n @li 0x10 = Fast Opto-Isolated Serial Mode (FT2232, FT2232H, FT4232H and FT232H devices only)\n @li 0x20 = CBUS Bit Bang Mode (FT232R and FT232H devices only)\n @li 0x40 = Single Channel Synchronous 245 FIFO Mode (FT2232H and FT232H devices only)\n @returns\n FT_OK if successful, otherwise the return value is an FT error code.\n @remarks\n For a description of available bit modes for the FT232R, see the application note \"Bit Bang Modes\n for the FT232R and FT245R\".\n @n For a description of available bit modes for the FT2232, see the application note \"Bit Mode\n Functions for the FT2232\".\n @n For a description of Bit Bang Mode for the FT232B and FT245B, see the application note\n \"FT232B/FT245B Bit Bang Mode\".\n @n Application notes are available for download from the FTDI website.\n Note that to use CBUS Bit Bang for the FT232R, the CBUS must be configured for CBUS Bit Bang in the\n EEPROM.\n @note Note that to use Single Channel Synchronous 245 FIFO mode for the FT2232H, channel A must be\n configured for FT245 FIFO mode in the EEPROM."]
    pub fn FT_SetBitMode(ftHandle: FT_HANDLE, ucMask: UCHAR, ucEnable: UCHAR) -> FT_STATUS;
}
unsafe extern "C" {
    #[doc = " @noop FT_GetBitMode\n @par Supported Operating Systems\n Linux\n Mac OS X (10.4 and later)\n Windows (2000 and later)\n Windows CE (4.2 and later)\n @par Summary\n Gets the instantaneous value of the data bus.\n @param ftHandle Handle of the device.\n @param pucMode Pointer to unsigned char to store the instantaneous data bus value.\n @returns\n FT_OK if successful, otherwise the return value is an FT error code.\n @remarks\n For a description of available bit modes for the FT232R, see the application note \"Bit Bang Modes\n for the FT232R and FT245R\".\n @n For a description of available bit modes for the FT2232, see the application note \"Bit Mode\n Functions for the FT2232\".\n @n For a description of bit bang modes for the FT232B and FT245B, see the application note\n \"FT232B/FT245B Bit Bang Mode\".\n @n For a description of bit modes supported by the FT4232H and FT2232H devices, please see the\n IC data sheets.\n @n These application notes are available for download from the FTDI website."]
    pub fn FT_GetBitMode(ftHandle: FT_HANDLE, pucMode: PUCHAR) -> FT_STATUS;
}
unsafe extern "C" {
    #[doc = " @noop FT_SetUSBParameters\n @par Supported Operating Systems\n Linux\n Mac OS X (10.4 and later)\n Windows (2000 and later)\n Windows CE (4.2 and later)\n @par Summary\n Set the USB request transfer size.\n @param ftHandle Handle of the device.\n @param ulInTransferSize Transfer size for USB IN request.\n @param ulOutTransferSize Transfer size for USB OUT request.\n @returns\n FT_OK if successful, otherwise the return value is an FT error code.\n @remarks\n This function can be used to change the transfer sizes from the default transfer size of 4096\n bytes to\tbetter suit the application requirements. Transfer sizes must be set to a multiple\n of 64 bytes between 64 bytes and 64k bytes.\n @n When FT_SetUSBParameters is called, the change comes into effect immediately and any data\n that was\theld in the driver at the time of the change is lost.\n @note Note that, at present, only ulInTransferSize is supported."]
    pub fn FT_SetUSBParameters(
        ftHandle: FT_HANDLE,
        ulInTransferSize: ULONG,
        ulOutTransferSize: ULONG,
    ) -> FT_STATUS;
}
unsafe extern "C" {
    #[doc = " @noop FT_W32_CreateFile\n @par Supported Operating Systems\n Linux\n Mac OS X (10.4 and later)\n Windows (2000 and later)\n Windows CE (4.2 and later)\n @par Summary\n Opens the specified device and return a handle which will be used for subsequent accesses.\n The device can be specified by its serial number, device description, or location.\n @n This function must be used if overlapped I/O is required.\n @param lpszName Meaning depends on the value of dwAttrsAndFlags. Can be a pointer to a null\n terminated string that contains the description or serial number of the device, or can be\n the location of the device. These values can be obtained from the FT_CreateDeviceInfoList,\n FT_GetDeviceInfoDetail or FT_ListDevices\tfunctions.\n @param dwAccess Type of access to the device. Access can be GENERIC_READ,\n GENERIC_WRITE or both. Ignored in Linux.\n @param dwShareMode How the device is shared. This value must be set to 0.\n @param lpSecurityAttributes This parameter has no effect and should be set to NULL.\n @param dwCreate This parameter must be set to OPEN_EXISTING. Ignored in Linux.\n @param dwAttrsAndFlags File attributes and flags. This parameter is a combination of\n FILE_ATTRIBUTE_NORMAL, FILE_FLAG_OVERLAPPED if overlapped I/O is used,\n FT_OPEN_BY_SERIAL_NUMBER if lpszName is the devices serial number, and\n FT_OPEN_BY_DESCRIPTION if lpszName is the devices description.\n @param hTemplate This parameter must be NULL.\n @returns\n If the function is successful, the return value is a handle.\n If the function is unsuccessful, the return value is the Win32 error code INVALID_HANDLE_VALUE.\n @remarks\n The meaning of lpszName depends on dwAttrsAndFlags: if FT_OPEN_BY_SERIAL_NUMBER or\n FT_OPEN_BY_DESCRIPTION is set in dwAttrsAndFlags, lpszName contains a pointer to a null terminated\n string that contains the device's serial number or description; if FT_OPEN_BY_LOCATION is set in\n dwAttrsAndFlags, lpszName is interpreted as a value of type long that contains the location ID of\n the device. dwAccess can be GENERIC_READ, GENERIC_WRITE or both; dwShareMode must be set to 0;\n lpSecurityAttributes must be set to NULL; dwCreate must be set to OPEN_EXISTING; dwAttrsAndFlags\n is a combination of FILE_ATTRIBUTE_NORMAL, FILE_FLAG_OVERLAPPED if overlapped I/O is used,\n FT_OPEN_BY_SERIAL_NUMBER or FT_OPEN_BY_DESCRIPTION or FT_OPEN_BY_LOCATION; hTemplate\n must be NULL.\n @note Note that Linux, Mac OS X and Windows CE do not support overlapped IO. Windows CE\n does not support location IDs."]
    pub fn FT_W32_CreateFile(
        lpszName: LPCTSTR,
        dwAccess: DWORD,
        dwShareMode: DWORD,
        lpSecurityAttributes: LPSECURITY_ATTRIBUTES,
        dwCreate: DWORD,
        dwAttrsAndFlags: DWORD,
        hTemplate: HANDLE,
    ) -> FT_HANDLE;
}
unsafe extern "C" {
    #[doc = " @noop FT_W32_CloseHandle\n @par Supported Operating Systems\n Linux\n Mac OS X (10.4 and later)\n Windows (2000 and later)\n Windows CE (4.2 and later)\n @par Summary\n Close the specified device handle.\n @param ftHandle Handle of the device.\n @returns\n If the function is successful, the return value is nonzero.\n If the function is unsuccessful, the return value is zero."]
    pub fn FT_W32_CloseHandle(ftHandle: FT_HANDLE) -> BOOL;
}
unsafe extern "C" {
    #[doc = " @noop FT_W32_ReadFile\n @par Supported Operating Systems\n Linux\n Mac OS X (10.4 and later)\n Windows (2000 and later)\n Windows CE (4.2 and later)\n @par Summary\n Read data from the device.\n @param ftHandle Handle of the device.\n @param lpBuffer Pointer to a buffer that receives the data from the device.\n @param nBufferSize Number of bytes to read from the device.\n @param lpdwBytesReturned Pointer to a variable that receives the number of bytes read from\n the device.\n @param lpOverlapped Pointer to an overlapped structure.\n @returns\n If the function is successful, the return value is nonzero.\n If the function is unsuccessful, the return value is zero.\n @remarks\n This function supports both non-overlapped and overlapped I/O, except under Linux, Mac OS X\n and Windows CE where only non-overlapped IO is supported.\n @n @b Non-overlapped @b I/O\n @n The parameter, lpOverlapped, must be NULL for non-overlapped I/O.\n @n This function always returns the number of bytes read in lpdwBytesReturned.\n This function does not return until dwBytesToRead have been read into the buffer. The number of\n bytes in the receive queue can be determined by calling FT_GetStatus or FT_GetQueueStatus, and\n passed as dwBytesToRead so that the function reads the device and returns immediately.\n @n When a read timeout has been setup in a previous call to FT_W32_SetCommTimeouts, this function\n returns when the timer expires or dwBytesToRead have been read, whichever occurs first. If a\n timeout occurred, any available data is read into lpBuffer and the function returns a non-zero value.\n @n An application should use the function return value and lpdwBytesReturned when processing the\n buffer. If the return value is non-zero and lpdwBytesReturned is equal to dwBytesToRead then the\n function has\tcompleted normally. If the return value is non-zero and lpdwBytesReturned is less\n then dwBytesToRead then a timeout has occurred, and the read request has been partially completed.\n @note Note that if a timeout\toccurred and no data was read, the return value is still non-zero.\n @n @b Overlapped @b I/O\n @n When the device has been opened for overlapped I/O, an application can issue a request and\n perform some additional work while the request is pending. This contrasts with the case\n of non-overlapped I/O in\twhich the application issues a request and receives control again only\n after the request has been completed.\n @n The parameter, lpOverlapped, must point to an initialized OVERLAPPED structure. If there is\n enough data in the receive queue to satisfy the request, the request completes immediately and\n the return code is non-zero. The number of bytes read is returned in lpdwBytesReturned.\n @n If there is not enough data in the receive queue to satisfy the request, the request completes\n immediately, and the return code is zero, signifying an error. An application should call\n FT_W32_GetLastError to get the cause of the error. If the error code is ERROR_IO_PENDING, the\n overlapped operation is still in progress, and the application can perform other processing.\n Eventually, the application checks the result of the overlapped request by calling\n FT_W32_GetOverlappedResult.\n @n If successful, the number of bytes read is returned in lpdwBytesReturned."]
    pub fn FT_W32_ReadFile(
        ftHandle: FT_HANDLE,
        lpBuffer: LPVOID,
        nBufferSize: DWORD,
        lpdwBytesReturned: LPDWORD,
        lpOverlapped: LPOVERLAPPED,
    ) -> BOOL;
}
unsafe extern "C" {
    #[doc = " @noop FT_W32_WriteFile\n @par Supported Operating Systems\n Linux\n Mac OS X (10.4 and later)\n Windows (2000 and later)\n Windows CE (4.2 and later)\n @par Summary\n Write data to the device.\n @param ftHandle Handle of the device.\n @param lpBuffer Pointer to the buffer that contains the data to write to the device.\n @param nBufferSize Number of bytes to be written to the device.\n @param lpdwBytesWritten Pointer to a variable that receives the number of bytes written to the device.\n @param lpOverlapped Pointer to an overlapped structure.\n @returns\n If the function is successful, the return value is nonzero.\n If the function is unsuccessful, the return value is zero.\n @remarks\n This function supports both non-overlapped and overlapped I/O, except under Linux, Mac OS X and\n Windows CE where only non-overlapped IO is supported.\n @n @b Non-overlapped @b I/O\n @n The parameter, lpOverlapped, must be NULL for non-overlapped I/O.\n @n This function always returns the number of bytes written in lpdwBytesWritten.\n This function does not return until dwBytesToWrite have been written to the device.\n When a write timeout has been setup in a previous call to FT_W32_SetCommTimeouts, this function\n returns when the timer expires or dwBytesToWrite have been written, whichever occurs first. If a\n timeout occurred, lpdwBytesWritten contains the number of bytes actually written, and the function\n returns a non-zero value.\n @n An application should always use the function return value and lpdwBytesWritten. If the return\n value is\tnon-zero and lpdwBytesWritten is equal to dwBytesToWrite then the function has completed\n normally. If\tthe return value is non-zero and lpdwBytesWritten is less then dwBytesToWrite then a\n timeout has occurred, and the write request has been partially completed.\n @note Note that if a timeout occurred and no data was written, the return value is still non-zero.\n @n @b Overlapped @b I/O\n @n When the device has been opened for overlapped I/O, an application can issue a request and perform\n some additional work while the request is pending. This contrasts with the case of non-overlapped\n I/O in which the application issues a request and receives control again only after the request has\n been\tcompleted.\n @n The parameter, lpOverlapped, must point to an initialized OVERLAPPED structure.\n This function completes immediately, and the return code is zero, signifying an error. An application\n should call FT_W32_GetLastError to get the cause of the error. If the error code is ERROR_IO_PENDING,\n the overlapped operation is still in progress, and the application can perform other processing.\n Eventually, the application checks the result of the overlapped request by calling\n FT_W32_GetOverlappedResult.\n @n If successful, the number of bytes written is returned in lpdwBytesWritten."]
    pub fn FT_W32_WriteFile(
        ftHandle: FT_HANDLE,
        lpBuffer: LPVOID,
        nBufferSize: DWORD,
        lpdwBytesWritten: LPDWORD,
        lpOverlapped: LPOVERLAPPED,
    ) -> BOOL;
}
unsafe extern "C" {
    #[doc = " @noop FT_W32_GetOverlappedResult\n @par Supported Operating Systems\n Linux\n Mac OS X (10.4 and later)\n Windows (2000 and later)\n Windows CE (4.2 and later)\n @par Summary\n Gets the result of an overlapped operation.\n @param ftHandle Handle of the device.\n @param lpOverlapped Pointer to an overlapped structure.\n @param lpdwBytesTransferred Pointer to a variable that receives the number of bytes transferred\n during the overlapped operation.\n @param bWait Set to TRUE if the function does not return until the operation has been completed.\n @returns\n If the function is successful, the return value is nonzero.\n If the function is unsuccessful, the return value is zero.\n @remarks\n This function is used with overlapped I/O and so is not supported in Linux, Mac OS X or Windows CE. For\n a description of its use, see FT_W32_ReadFile and FT_W32_WriteFile."]
    pub fn FT_W32_GetOverlappedResult(
        ftHandle: FT_HANDLE,
        lpOverlapped: LPOVERLAPPED,
        lpdwBytesTransferred: LPDWORD,
        bWait: BOOL,
    ) -> BOOL;
}
unsafe extern "C" {
    #[doc = " @noop FT_W32_EscapeCommFunction\n @par Supported Operating Systems\n Linux\n Mac OS X (10.4 and later)\n Windows (2000 and later)\n Windows CE (4.2 and later)\n @par Summary\n Perform an extended function.\n @param ftHandle Handle of the device.\n @param dwFunc The extended function to perform can be one of the following values:\n @li CLRDTR - Clear the DTR signal\n @li CLRRTS - Clear the RTS signal\n @li SETDTR - Set the DTR signal\n @li SETRTS - Set the RTS signal\n @li SETBREAK - Set the BREAK condition\n @li CLRBREAK - Clear the BREAK condition\n @returns\n If the function is successful, the return value is nonzero.\n If the function is unsuccessful, the return value is zero."]
    pub fn FT_W32_EscapeCommFunction(ftHandle: FT_HANDLE, dwFunc: DWORD) -> BOOL;
}
unsafe extern "C" {
    #[doc = " @noop FT_W32_GetCommModemStatus\n @par Supported Operating Systems\n Linux\n Mac OS X (10.4 and later)\n Windows (2000 and later)\n Windows CE (4.2 and later)\n @par Summary\n This function gets the current modem control value.\n @param ftHandle Handle of the device.\n @param lpdwModemStatus Pointer to a variable to contain modem control value. The modem\n control value can be a combination of the following:\n @li MS_CTS_ON - Clear To Send (CTS) is on\n @li MS_DSR_ON - Data Set Ready (DSR) is on\n @li MS_RING_ON - Ring Indicator (RI) is on\n @li MS_RLSD_ON - Receive Line Signal Detect (RLSD) is on\n @returns\n If the function is successful, the return value is nonzero.\n If the function is unsuccessful, the return value is zero."]
    pub fn FT_W32_GetCommModemStatus(ftHandle: FT_HANDLE, lpdwModemStatus: LPDWORD) -> BOOL;
}
unsafe extern "C" {
    #[doc = " @noop FT_W32_SetupComm\n @par Supported Operating Systems\n Linux\n Mac OS X (10.4 and later)\n Windows (2000 and later)\n Windows CE (4.2 and later)\n @par Summary\n This function sets the read and write buffers.\n @param ftHandle Handle of the device.\n @param dwReadBufferSize Length, in bytes, of the read buffer.\n @param dwWriteBufferSize Length, in bytes, of the write buffer.\n @returns\n If the function is successful, the return value is nonzero.\n If the function is unsuccessful, the return value is zero.\n @remarks\n This function has no effect. It is the responsibility of the driver to allocate sufficient\n storage for I/O requests."]
    pub fn FT_W32_SetupComm(
        ftHandle: FT_HANDLE,
        dwReadBufferSize: DWORD,
        dwWriteBufferSize: DWORD,
    ) -> BOOL;
}
#[doc = " Structure for FT_W32_ClearCommError lpftComstat parameter.\n @see FT_W32_ClearCommError"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FTCOMSTAT {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub cbInQue: DWORD,
    pub cbOutQue: DWORD,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _FTCOMSTAT"][::std::mem::size_of::<_FTCOMSTAT>() - 12usize];
    ["Alignment of _FTCOMSTAT"][::std::mem::align_of::<_FTCOMSTAT>() - 4usize];
    ["Offset of field: _FTCOMSTAT::cbInQue"][::std::mem::offset_of!(_FTCOMSTAT, cbInQue) - 4usize];
    ["Offset of field: _FTCOMSTAT::cbOutQue"]
        [::std::mem::offset_of!(_FTCOMSTAT, cbOutQue) - 8usize];
};
impl _FTCOMSTAT {
    #[inline]
    pub fn fCtsHold(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fCtsHold(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn fCtsHold_raw(this: *const Self) -> DWORD {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_fCtsHold_raw(this: *mut Self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn fDsrHold(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fDsrHold(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn fDsrHold_raw(this: *const Self) -> DWORD {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_fDsrHold_raw(this: *mut Self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn fRlsdHold(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fRlsdHold(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn fRlsdHold_raw(this: *const Self) -> DWORD {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_fRlsdHold_raw(this: *mut Self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn fXoffHold(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fXoffHold(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn fXoffHold_raw(this: *const Self) -> DWORD {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_fXoffHold_raw(this: *mut Self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn fXoffSent(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fXoffSent(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn fXoffSent_raw(this: *const Self) -> DWORD {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_fXoffSent_raw(this: *mut Self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn fEof(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fEof(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn fEof_raw(this: *const Self) -> DWORD {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_fEof_raw(this: *mut Self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn fTxim(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fTxim(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn fTxim_raw(this: *const Self) -> DWORD {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_fTxim_raw(this: *mut Self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn fReserved(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 25u8) as u32) }
    }
    #[inline]
    pub fn set_fReserved(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 25u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn fReserved_raw(this: *const Self) -> DWORD {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                25u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_fReserved_raw(this: *mut Self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                25u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        fCtsHold: DWORD,
        fDsrHold: DWORD,
        fRlsdHold: DWORD,
        fXoffHold: DWORD,
        fXoffSent: DWORD,
        fEof: DWORD,
        fTxim: DWORD,
        fReserved: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let fCtsHold: u32 = unsafe { ::std::mem::transmute(fCtsHold) };
            fCtsHold as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let fDsrHold: u32 = unsafe { ::std::mem::transmute(fDsrHold) };
            fDsrHold as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let fRlsdHold: u32 = unsafe { ::std::mem::transmute(fRlsdHold) };
            fRlsdHold as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let fXoffHold: u32 = unsafe { ::std::mem::transmute(fXoffHold) };
            fXoffHold as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let fXoffSent: u32 = unsafe { ::std::mem::transmute(fXoffSent) };
            fXoffSent as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let fEof: u32 = unsafe { ::std::mem::transmute(fEof) };
            fEof as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let fTxim: u32 = unsafe { ::std::mem::transmute(fTxim) };
            fTxim as u64
        });
        __bindgen_bitfield_unit.set(7usize, 25u8, {
            let fReserved: u32 = unsafe { ::std::mem::transmute(fReserved) };
            fReserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Structure for FT_W32_ClearCommError lpftComstat parameter.\n @see FT_W32_ClearCommError"]
pub type LPFTCOMSTAT = *mut _FTCOMSTAT;
#[doc = " Structure for FT_W32_SetCommState and FT_W32_GetCommState lpftDcb parameter.\n @see FT_W32_SetCommState\n @see FT_W32_GetCommState"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FTDCB {
    pub DCBlength: DWORD,
    #[doc = " sizeof(FTDCB)"]
    pub BaudRate: DWORD,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = " Reserved"]
    pub wReserved: WORD,
    #[doc = " Not currently used"]
    pub XonLim: WORD,
    #[doc = " Transmit X-ON threshold"]
    pub XoffLim: WORD,
    #[doc = " Transmit X-OFF threshold"]
    pub ByteSize: BYTE,
    #[doc = " Number of bits/byte, 4-8"]
    pub Parity: BYTE,
    #[doc = " 0-4=None,Odd,Even,Mark,Space"]
    pub StopBits: BYTE,
    #[doc = " FT_STOP_BITS_1 or FT_STOP_BITS_2"]
    pub XonChar: ::std::os::raw::c_char,
    #[doc = " Tx and Rx X-ON character"]
    pub XoffChar: ::std::os::raw::c_char,
    #[doc = " Tx and Rx X-OFF character"]
    pub ErrorChar: ::std::os::raw::c_char,
    #[doc = " Error replacement char"]
    pub EofChar: ::std::os::raw::c_char,
    #[doc = " End of Input character"]
    pub EvtChar: ::std::os::raw::c_char,
    #[doc = " Received Event character"]
    pub wReserved1: WORD,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _FTDCB"][::std::mem::size_of::<_FTDCB>() - 28usize];
    ["Alignment of _FTDCB"][::std::mem::align_of::<_FTDCB>() - 4usize];
    ["Offset of field: _FTDCB::DCBlength"][::std::mem::offset_of!(_FTDCB, DCBlength) - 0usize];
    ["Offset of field: _FTDCB::BaudRate"][::std::mem::offset_of!(_FTDCB, BaudRate) - 4usize];
    ["Offset of field: _FTDCB::wReserved"][::std::mem::offset_of!(_FTDCB, wReserved) - 12usize];
    ["Offset of field: _FTDCB::XonLim"][::std::mem::offset_of!(_FTDCB, XonLim) - 14usize];
    ["Offset of field: _FTDCB::XoffLim"][::std::mem::offset_of!(_FTDCB, XoffLim) - 16usize];
    ["Offset of field: _FTDCB::ByteSize"][::std::mem::offset_of!(_FTDCB, ByteSize) - 18usize];
    ["Offset of field: _FTDCB::Parity"][::std::mem::offset_of!(_FTDCB, Parity) - 19usize];
    ["Offset of field: _FTDCB::StopBits"][::std::mem::offset_of!(_FTDCB, StopBits) - 20usize];
    ["Offset of field: _FTDCB::XonChar"][::std::mem::offset_of!(_FTDCB, XonChar) - 21usize];
    ["Offset of field: _FTDCB::XoffChar"][::std::mem::offset_of!(_FTDCB, XoffChar) - 22usize];
    ["Offset of field: _FTDCB::ErrorChar"][::std::mem::offset_of!(_FTDCB, ErrorChar) - 23usize];
    ["Offset of field: _FTDCB::EofChar"][::std::mem::offset_of!(_FTDCB, EofChar) - 24usize];
    ["Offset of field: _FTDCB::EvtChar"][::std::mem::offset_of!(_FTDCB, EvtChar) - 25usize];
    ["Offset of field: _FTDCB::wReserved1"][::std::mem::offset_of!(_FTDCB, wReserved1) - 26usize];
};
impl _FTDCB {
    #[inline]
    pub fn fBinary(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fBinary(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn fBinary_raw(this: *const Self) -> DWORD {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_fBinary_raw(this: *mut Self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn fParity(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fParity(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn fParity_raw(this: *const Self) -> DWORD {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_fParity_raw(this: *mut Self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn fOutxCtsFlow(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fOutxCtsFlow(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn fOutxCtsFlow_raw(this: *const Self) -> DWORD {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_fOutxCtsFlow_raw(this: *mut Self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn fOutxDsrFlow(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fOutxDsrFlow(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn fOutxDsrFlow_raw(this: *const Self) -> DWORD {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_fOutxDsrFlow_raw(this: *mut Self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn fDtrControl(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_fDtrControl(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn fDtrControl_raw(this: *const Self) -> DWORD {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_fDtrControl_raw(this: *mut Self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn fDsrSensitivity(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fDsrSensitivity(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn fDsrSensitivity_raw(this: *const Self) -> DWORD {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_fDsrSensitivity_raw(this: *mut Self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn fTXContinueOnXoff(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fTXContinueOnXoff(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn fTXContinueOnXoff_raw(this: *const Self) -> DWORD {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_fTXContinueOnXoff_raw(this: *mut Self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn fOutX(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fOutX(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn fOutX_raw(this: *const Self) -> DWORD {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_fOutX_raw(this: *mut Self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn fInX(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fInX(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn fInX_raw(this: *const Self) -> DWORD {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_fInX_raw(this: *mut Self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn fErrorChar(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fErrorChar(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn fErrorChar_raw(this: *const Self) -> DWORD {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_fErrorChar_raw(this: *mut Self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn fNull(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fNull(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn fNull_raw(this: *const Self) -> DWORD {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_fNull_raw(this: *mut Self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn fRtsControl(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_fRtsControl(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn fRtsControl_raw(this: *const Self) -> DWORD {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_fRtsControl_raw(this: *mut Self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn fAbortOnError(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fAbortOnError(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn fAbortOnError_raw(this: *const Self) -> DWORD {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_fAbortOnError_raw(this: *mut Self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn fDummy2(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 17u8) as u32) }
    }
    #[inline]
    pub fn set_fDummy2(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 17u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn fDummy2_raw(this: *const Self) -> DWORD {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                17u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_fDummy2_raw(this: *mut Self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                17u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        fBinary: DWORD,
        fParity: DWORD,
        fOutxCtsFlow: DWORD,
        fOutxDsrFlow: DWORD,
        fDtrControl: DWORD,
        fDsrSensitivity: DWORD,
        fTXContinueOnXoff: DWORD,
        fOutX: DWORD,
        fInX: DWORD,
        fErrorChar: DWORD,
        fNull: DWORD,
        fRtsControl: DWORD,
        fAbortOnError: DWORD,
        fDummy2: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let fBinary: u32 = unsafe { ::std::mem::transmute(fBinary) };
            fBinary as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let fParity: u32 = unsafe { ::std::mem::transmute(fParity) };
            fParity as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let fOutxCtsFlow: u32 = unsafe { ::std::mem::transmute(fOutxCtsFlow) };
            fOutxCtsFlow as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let fOutxDsrFlow: u32 = unsafe { ::std::mem::transmute(fOutxDsrFlow) };
            fOutxDsrFlow as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let fDtrControl: u32 = unsafe { ::std::mem::transmute(fDtrControl) };
            fDtrControl as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let fDsrSensitivity: u32 = unsafe { ::std::mem::transmute(fDsrSensitivity) };
            fDsrSensitivity as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let fTXContinueOnXoff: u32 = unsafe { ::std::mem::transmute(fTXContinueOnXoff) };
            fTXContinueOnXoff as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let fOutX: u32 = unsafe { ::std::mem::transmute(fOutX) };
            fOutX as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let fInX: u32 = unsafe { ::std::mem::transmute(fInX) };
            fInX as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let fErrorChar: u32 = unsafe { ::std::mem::transmute(fErrorChar) };
            fErrorChar as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let fNull: u32 = unsafe { ::std::mem::transmute(fNull) };
            fNull as u64
        });
        __bindgen_bitfield_unit.set(12usize, 2u8, {
            let fRtsControl: u32 = unsafe { ::std::mem::transmute(fRtsControl) };
            fRtsControl as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let fAbortOnError: u32 = unsafe { ::std::mem::transmute(fAbortOnError) };
            fAbortOnError as u64
        });
        __bindgen_bitfield_unit.set(15usize, 17u8, {
            let fDummy2: u32 = unsafe { ::std::mem::transmute(fDummy2) };
            fDummy2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Structure for FT_W32_SetCommState and FT_W32_GetCommState lpftDcb parameter.\n @see FT_W32_SetCommState\n @see FT_W32_GetCommState"]
pub type LPFTDCB = *mut _FTDCB;
#[doc = " Structure for FT_W32_SetCommTimeouts and FT_W32_GetCommTimeouts lpftTimeouts parameter.\n @see FT_W32_SetCommTimeouts\n @see FT_W32_GetCommTimeouts"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FTTIMEOUTS {
    pub ReadIntervalTimeout: DWORD,
    #[doc = " Maximum time between read chars."]
    pub ReadTotalTimeoutMultiplier: DWORD,
    #[doc = " Multiplier of characters."]
    pub ReadTotalTimeoutConstant: DWORD,
    #[doc = " Constant in milliseconds."]
    pub WriteTotalTimeoutMultiplier: DWORD,
    #[doc = " Multiplier of characters."]
    pub WriteTotalTimeoutConstant: DWORD,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _FTTIMEOUTS"][::std::mem::size_of::<_FTTIMEOUTS>() - 20usize];
    ["Alignment of _FTTIMEOUTS"][::std::mem::align_of::<_FTTIMEOUTS>() - 4usize];
    ["Offset of field: _FTTIMEOUTS::ReadIntervalTimeout"]
        [::std::mem::offset_of!(_FTTIMEOUTS, ReadIntervalTimeout) - 0usize];
    ["Offset of field: _FTTIMEOUTS::ReadTotalTimeoutMultiplier"]
        [::std::mem::offset_of!(_FTTIMEOUTS, ReadTotalTimeoutMultiplier) - 4usize];
    ["Offset of field: _FTTIMEOUTS::ReadTotalTimeoutConstant"]
        [::std::mem::offset_of!(_FTTIMEOUTS, ReadTotalTimeoutConstant) - 8usize];
    ["Offset of field: _FTTIMEOUTS::WriteTotalTimeoutMultiplier"]
        [::std::mem::offset_of!(_FTTIMEOUTS, WriteTotalTimeoutMultiplier) - 12usize];
    ["Offset of field: _FTTIMEOUTS::WriteTotalTimeoutConstant"]
        [::std::mem::offset_of!(_FTTIMEOUTS, WriteTotalTimeoutConstant) - 16usize];
};
#[doc = " Structure for FT_W32_SetCommTimeouts and FT_W32_GetCommTimeouts lpftTimeouts parameter.\n @see FT_W32_SetCommTimeouts\n @see FT_W32_GetCommTimeouts"]
pub type FTTIMEOUTS = _FTTIMEOUTS;
unsafe extern "C" {
    #[doc = " @noop FT_W32_SetCommState\n @par Supported Operating Systems\n Linux\n Mac OS X (10.4 and later)\n Windows (2000 and later)\n Windows CE (4.2 and later)\n @par Summary\n This function sets the state of the device according to the contents of a device control block (DCB).\n @param ftHandle Handle of the device.\n @param lpftDcb Pointer to an FTDCB structure.\n @returns\n If the function is successful, the return value is nonzero.\n If the function is unsuccessful, the return value is zero."]
    pub fn FT_W32_SetCommState(ftHandle: FT_HANDLE, lpftDcb: LPFTDCB) -> BOOL;
}
unsafe extern "C" {
    #[doc = " @noop FT_W32_GetCommState\n @par Supported Operating Systems\n Linux\n Mac OS X (10.4 and later)\n Windows (2000 and later)\n Windows CE (4.2 and later)\n @par Summary\n This function gets the current device state.\n @param ftHandle Handle of the device.\n @param lpftDcb Pointer to an FTDCB structure.\n @returns\n If the function is successful, the return value is nonzero.\n If the function is unsuccessful, the return value is zero.\n @remarks\n The current state of the device is returned in a device control block."]
    pub fn FT_W32_GetCommState(ftHandle: FT_HANDLE, lpftDcb: LPFTDCB) -> BOOL;
}
unsafe extern "C" {
    #[doc = " @noop FT_W32_SetCommTimeouts\n @par Supported Operating Systems\n Linux\n Mac OS X (10.4 and later)\n Windows (2000 and later)\n Windows CE (4.2 and later)\n @par Summary\n This function sets the timeout parameters for I/O requests.\n @param ftHandle Handle of the device.\n @param pftTimeouts Pointer to an FTTIMEOUTS structure to store timeout information.\n @returns\n If the function is unsuccessful, the return value is zero.\n @remarks\n Timeouts are calculated using the information in the FTTIMEOUTS structure.\n @n For read requests, the number of bytes to be read is multiplied by the total timeout\n multiplier, and added to the total timeout constant. So, if TS is an FTTIMEOUTS structure\n and the number of bytes to read is dwToRead, the read timeout, rdTO, is calculated as follows.\n @n rdTO = (dwToRead * TS.ReadTotalTimeoutMultiplier) + TS.ReadTotalTimeoutConstant\n @n For write requests, the number of bytes to be written is multiplied by the total timeout\n multiplier, and added to the total timeout constant. So, if TS is an FTTIMEOUTS structure\n and the number of bytes to write is dwToWrite, the write timeout, wrTO, is calculated as follows.\n @n wrTO = (dwToWrite * TS.WriteTotalTimeoutMultiplier) + TS.WriteTotalTimeoutConstant\n @n Linux and Mac OS X currently ignore the ReadIntervalTimeout, ReadTotalTimeoutMultiplier and\n WriteTotalTimeoutMultiplier."]
    pub fn FT_W32_SetCommTimeouts(ftHandle: FT_HANDLE, pftTimeouts: *mut FTTIMEOUTS) -> BOOL;
}
unsafe extern "C" {
    #[doc = " @noop FT_W32_GetCommTimeouts\n @par Supported Operating Systems\n Linux\n Mac OS X (10.4 and later)\n Windows (2000 and later)\n Windows CE (4.2 and later)\n @par Summary\n This function gets the current read and write request timeout parameters for the specified device.\n @param ftHandle Handle of the device.\n @param pftTimeouts Pointer to an FTTIMEOUTS structure to store timeout information.\n @returns\n If the function is successful, the return value is nonzero.\n If the function is unsuccessful, the return value is zero.\n @remarks\n For an explanation of how timeouts are used, see FT_W32_SetCommTimeouts."]
    pub fn FT_W32_GetCommTimeouts(ftHandle: FT_HANDLE, pftTimeouts: *mut FTTIMEOUTS) -> BOOL;
}
unsafe extern "C" {
    #[doc = " @noop FT_W32_SetCommBreak\n @par Supported Operating Systems\n Linux\n Mac OS X (10.4 and later)\n Windows (2000 and later)\n Windows CE (4.2 and later)\n @par Summary\n Puts the communications line in the BREAK state.\n @param ftHandle Handle of the device.\n @returns\n If the function is successful, the return value is nonzero.\n If the function is unsuccessful, the return value is zero."]
    pub fn FT_W32_SetCommBreak(ftHandle: FT_HANDLE) -> BOOL;
}
unsafe extern "C" {
    #[doc = " @noop FT_W32_ClearCommBreak\n @par Supported Operating Systems\n Linux\n Mac OS X (10.4 and later)\n Windows (2000 and later)\n Windows CE (4.2 and later)\n @par Summary\n Puts the communications line in the non-BREAK state.\n @param ftHandle Handle of the device.\n @returns\n If the function is successful, the return value is nonzero.\n If the function is unsuccessful, the return value is zero."]
    pub fn FT_W32_ClearCommBreak(ftHandle: FT_HANDLE) -> BOOL;
}
unsafe extern "C" {
    #[doc = " @noop FT_W32_SetCommMask\n @par Supported Operating Systems\n Linux\n Mac OS X (10.4 and later)\n Windows (2000 and later)\n Windows CE (4.2 and later)\n @par Summary\n This function specifies events that the device has to monitor.\n @param ftHandle Handle of the device.\n @param ulEventMask Mask containing events that the device has to monitor. This can be a combination of\n the following:\n @li EV_BREAK - BREAK condition detected\n @li EV_CTS - Change in Clear To Send (CTS)\n @li EV_DSR - Change in Data Set Ready (DSR)\n @li EV_ERR - Error in line status\n @li EV_RING - Change in Ring Indicator (RI)\n @li EV_RLSD - Change in Receive Line Signal Detect (RLSD)\n @li EV_RXCHAR - Character received\n @li EV_RXFLAG - Event character received\n @li EV_TXEMPTY - Transmitter empty\n @returns\n If the function is successful, the return value is nonzero.\n If the function is unsuccessful, the return value is zero.\n @remarks\n This function specifies the events that the device should monitor. An application can call the\n function FT_W32_WaitCommEvent to wait for an event to occur."]
    pub fn FT_W32_SetCommMask(ftHandle: FT_HANDLE, ulEventMask: ULONG) -> BOOL;
}
unsafe extern "C" {
    #[doc = " @noop 6 FT_W32_GetCommMask\n @par Supported Operating Systems\n Windows (2000 and later)\n @par Summary\n Retrieves the events that are currently being monitored by a device.\n @param ftHandle Handle of the device.\n @param lpdwEventMask Pointer to a location that receives a mask that contains the events that are\n currently enabled. This parameter can be one or more of the following values:\n @li EV_BREAK - BREAK condition detected\n @li EV_CTS - Change in Clear To Send (CTS)\n @li EV_DSR - Change in Data Set Ready (DSR)\n @li EV_ERR - Error in line status\n @li EV_RING - Change in Ring Indicator (RI)\n @li EV_RLSD - Change in Receive Line Signal Detect (RLSD)\n @li EV_RXCHAR - Character received\n @li EV_RXFLAG - Event character received\n @li EV_TXEMPTY - Transmitter empty\n @returns\n If the function is successful, the return value is nonzero.\n If the function is unsuccessful, the return value is zero.\n @remarks\n This function returns events currently being monitored by the device. Event monitoring for these\n events is enabled by the FT_W32_SetCommMask function."]
    pub fn FT_W32_GetCommMask(ftHandle: FT_HANDLE, lpdwEventMask: LPDWORD) -> BOOL;
}
unsafe extern "C" {
    #[doc = " @noop FT_W32_WaitCommEvent\n @par Supported Operating Systems\n Linux\n Mac OS X (10.4 and later)\n Windows (2000 and later)\n Windows CE (4.2 and later)\n @par Summary\n This function waits for an event to occur.\n @param ftHandle Handle of the device.\n @param pulEvent Pointer to a location that receives a mask that contains the events that occurred.\n @param lpOverlapped Pointer to an overlapped structure.\n @returns\n If the function is successful, the return value is nonzero.\n If the function is unsuccessful, the return value is zero.\n @remarks\n This function supports both non-overlapped and overlapped I/O, except under Windows CE and Linux\n where only non-overlapped IO is supported.\n @n @b Non-overlapped @b I/O\n The parameter, lpOverlapped, must be NULL for non-overlapped I/O.\n @n This function does not return until an event that has been specified in a call to\n FT_W32_SetCommMask has occurred. The events that occurred and resulted in this function returning\n are stored in lpdwEvent.\n @n @b Overlapped @b I/O\n @n When the device has been opened for overlapped I/O, an application can issue a request and perform\n some additional work while the request is pending. This contrasts with the case of non-overlapped\n I/O in which the application issues a request and receives control again only after the request has\n been\tcompleted.\n @n The parameter, lpOverlapped, must point to an initialized OVERLAPPED structure.\n This function does not return until an event that has been specified in a call to FT_W32_SetCommMask\n has occurred.\n @n If an event has already occurred, the request completes immediately, and the return code is non-zero.\n @n The events that occurred are stored in lpdwEvent.\n @n If an event has not yet occurred, the request completes immediately, and the return code is zero,\n signifying an error. An application should call FT_W32_GetLastError to get the cause of the error. If\n the error code is ERROR_IO_PENDING, the overlapped operation is still in progress, and the application\n can perform other processing. Eventually, the application checks the result of the overlapped request\n by calling FT_W32_GetOverlappedResult. The events that occurred and resulted in this function\n returning are stored in lpdwEvent."]
    pub fn FT_W32_WaitCommEvent(
        ftHandle: FT_HANDLE,
        pulEvent: PULONG,
        lpOverlapped: LPOVERLAPPED,
    ) -> BOOL;
}
unsafe extern "C" {
    #[doc = " @noop FT_W32_PurgeComm\n @par Supported Operating Systems\n Linux\n Mac OS X (10.4 and later)\n Windows (2000 and later)\n Windows CE (4.2 and later)\n @par Summary\n This function purges the device.\n @param ftHandle Handle of the device.\n @param dwMask Specifies the action to take. The action can be a combination of the following:\n @li PURGE_TXABORT - Terminate outstanding overlapped writes\n @li PURGE_RXABORT - Terminate outstanding overlapped reads\n @li PURGE_TXCLEAR - Clear the transmit buffer\n @li PURGE_RXCLEAR - Clear the receive buffer\n @returns\n If the function is successful, the return value is nonzero.\n If the function is unsuccessful, the return value is zero."]
    pub fn FT_W32_PurgeComm(ftHandle: FT_HANDLE, dwMask: DWORD) -> BOOL;
}
unsafe extern "C" {
    #[doc = " @noop FT_W32_GetLastError\n @par Supported Operating Systems\n Linux\n Mac OS X (10.4 and later)\n Windows (2000 and later)\n Windows CE (4.2 and later)\n @par Summary\n Gets the last error that occurred on the device.\n @param ftHandle Handle of the device.\n @returns\n If the function is successful, the return value is nonzero.\n If the function is unsuccessful, the return value is zero.\n @remarks\n This function is normally used with overlapped I/O and so is not supported in Windows CE. For a\n description of its use, see FT_W32_ReadFile and FT_W32_WriteFile.\n @n In Linux and Mac OS X, this function returns a DWORD that directly maps to the FT Errors (for\n example the FT_INVALID_HANDLE error number)."]
    pub fn FT_W32_GetLastError(ftHandle: FT_HANDLE) -> DWORD;
}
unsafe extern "C" {
    #[doc = " @noop FT_W32_ClearCommError\n @par Supported Operating Systems\n Linux\n Mac OS X (10.4 and later)\n Windows (2000 and later)\n Windows CE (4.2 and later)\n @par Summary\n Gets information about a communications error and get current status of the device.\n @param ftHandle Handle of the device.\n @param lpdwErrors Variable that contains the error mask.\n @param lpftComstat Pointer to FTCOMSTAT structure.\n @returns\n If the function is successful, the return value is nonzero.\n If the function is unsuccessful, the return value is zero."]
    pub fn FT_W32_ClearCommError(
        ftHandle: FT_HANDLE,
        lpdwErrors: LPDWORD,
        lpftComstat: LPFTCOMSTAT,
    ) -> BOOL;
}
unsafe extern "C" {
    #[doc = " @noop FT_W32_CancelIo\n Undocumented function."]
    pub fn FT_W32_CancelIo(ftHandle: FT_HANDLE) -> BOOL;
}
unsafe extern "C" {
    #[doc = " @noop FT_EE_ReadConfig\n Undocumented function."]
    pub fn FT_EE_ReadConfig(ftHandle: FT_HANDLE, ucAddress: UCHAR, pucValue: PUCHAR) -> FT_STATUS;
}
unsafe extern "C" {
    #[doc = " @noop FT_EE_WriteConfig\n Undocumented function."]
    pub fn FT_EE_WriteConfig(ftHandle: FT_HANDLE, ucAddress: UCHAR, ucValue: UCHAR) -> FT_STATUS;
}
unsafe extern "C" {
    #[doc = " @noop FT_EE_ReadECC\n Undocumented function."]
    pub fn FT_EE_ReadECC(ftHandle: FT_HANDLE, ucOption: UCHAR, lpwValue: LPWORD) -> FT_STATUS;
}
unsafe extern "C" {
    #[doc = " @noop FT_GetQueueStatusEx\n Undocumented function."]
    pub fn FT_GetQueueStatusEx(ftHandle: FT_HANDLE, dwRxBytes: *mut DWORD) -> FT_STATUS;
}
unsafe extern "C" {
    #[doc = " @noop FT_ComPortIdle\n Undocumented function."]
    pub fn FT_ComPortIdle(ftHandle: FT_HANDLE) -> FT_STATUS;
}
unsafe extern "C" {
    #[doc = " @noop FT_ComPortCancelIdle\n Undocumented function."]
    pub fn FT_ComPortCancelIdle(ftHandle: FT_HANDLE) -> FT_STATUS;
}
unsafe extern "C" {
    #[doc = " @noop FT_VendorCmdGet\n Undocumented function."]
    pub fn FT_VendorCmdGet(
        ftHandle: FT_HANDLE,
        Request: UCHAR,
        Buf: *mut UCHAR,
        Len: USHORT,
    ) -> FT_STATUS;
}
unsafe extern "C" {
    #[doc = " @noop FT_VendorCmdSet\n Undocumented function."]
    pub fn FT_VendorCmdSet(
        ftHandle: FT_HANDLE,
        Request: UCHAR,
        Buf: *mut UCHAR,
        Len: USHORT,
    ) -> FT_STATUS;
}
unsafe extern "C" {
    #[doc = " @noop FT_VendorCmdGetEx\n Undocumented function."]
    pub fn FT_VendorCmdGetEx(
        ftHandle: FT_HANDLE,
        wValue: USHORT,
        Buf: *mut UCHAR,
        Len: USHORT,
    ) -> FT_STATUS;
}
unsafe extern "C" {
    #[doc = " @noop FT_VendorCmdSetEx\n Undocumented function."]
    pub fn FT_VendorCmdSetEx(
        ftHandle: FT_HANDLE,
        wValue: USHORT,
        Buf: *mut UCHAR,
        Len: USHORT,
    ) -> FT_STATUS;
}
